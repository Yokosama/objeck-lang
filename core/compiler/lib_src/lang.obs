#~
Objeck system classes.
Copyright (c) 2008-2020 Randy Hollines
note: compile compiler with -D_SYSTEM flag
~#	

#~
Core system classes 
~#
bundle System {
	#~
	Boolean class
	~#	
	class $Bool {
		#~
		Prints a boolean value
		@ignore-params
		~#
		function : Print(b : Bool) ~ Nil {
			STD_OUT_BOOL;
		}

		function : Size(v : Bool) ~ Int {
			if(v) {
				return 1;
			};

			return 0;
		}

		#~
		Prints a boolean value with a newline
		@ignore-params
		~#
		function : PrintLine(b : Bool) ~ Nil {
			STD_OUT_BOOL;
			'\n'->Print();
		}

		#~
		Prints an error boolean value
		@ignore-params
		~#
		function : Error(b : Bool) ~ Nil {
			STD_ERR_BOOL;
		}

		#~
		Prints an error boolean value with a newline
		@ignore-params
		~#
		function : ErrorLine(b : Bool) ~ Nil {
			STD_ERR_BOOL;
			'\n'->Error();
		}

		function : Size(b : Bool[]) ~ Int {
			LOAD_ARY_SIZE;
		}

		function : Size(b : Bool[,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		function : Size(b : Bool[,,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		#~
		Formats the boolean value into a string
		@ignore-params
		@return string value
		~#
		function : native : ToString(b : Bool) ~ String {
			string : String;

			if(b = true) {
				string := "true";
			}
			else {
			 	string := "false";
			};

			return string;			
		}
	}
	
	class Number {
		function : IntToString(value : Int, base : Int, buffer : Char[]) ~ Nil {
			I2S;
		}

		function : FloatToString(value : Float, buffer : Char[]) ~ Nil {
			F2S;
		}
	}
	
	#~
	The byte class represents a 1-byte value.
	~#
	class $Byte {
		#~
		Compresses a byte stream using zlib
		@ignore-params
		@return compressed bytes
		~#
		function : Compress(in : Byte[]) ~ Byte[] {
			COMPRESS_BYTES;
		}

		#~
		Uncompresses a byte stream using zlib
		@ignore-params
		@return uncompressed bytes
		~#
		function : Uncompress(in : Byte[]) ~ Byte[] {
			UNCOMPRESS_BYTES;
		}

		#~
		Calculates the signed CRC32 value for the stream
		@ignore-params
		@return signed CRC32
		~#
		function : CRC32(in : Byte[]) ~ Int {
			CRC32_BYTES;
		}
		
		#~
		Returns the smallest byte value
		@param l value to compare
		@param r value to compare
		@return smallest byte value
		~#
		function : Min(l : Byte, r : Byte) ~ Byte {
			if(l < r) {
				return l;
			};

			return r;
		}

		#~
		Returns the largest byte value
		@param l value to compare
		@param r value to compare
		@return largest byte value
		~#
		function : Max(l : Byte, r : Byte) ~ Byte {
			if(l > r) {
				return l;
			};

			return r;
		}

		#~
		Compares two values
		@param l left compare object
		@param r right compare object
		@return 0 if equal, -1 if types differ, 1 if equal
		~#
		function : native : Compare(l : Byte, r : Byte) ~ Int {
			if(l < r) {
				return -l;
			}
			else if(l > r) {
				return l;
			};

			return 0;
		}

        #~
        Returns the Float value
        @ignore-params
        @return value
        ~#
        function : ToFloat(v : Byte) ~ Float {
                return v->As(Float);
        }

        #~
        Returns the Character value
        @ignore-params
        @return value
        ~#
        function : ToChar(v : Byte) ~ Char {
                return v->As(Char);
        }

        #~
        Returns the Int value
        @ignore-params
        @return value
        ~#
        function : ToInt(v : Byte) ~ Int {
                return v->As(Int);
        }

        function : Size(v : Byte) ~ Byte {
			return v;
		}
        
		#~
		Returns the absolute value
		@ignore-params
		@return absolute value
		~#
		function : native : Abs(v : Byte) ~ Byte {
			if(v < 0) {
				return v * -1;
			};

			return v;
		}

		#~
		Prints value 
		@ignore-params
		~#
		function : Print(b : Byte) ~ Nil {
			STD_OUT_BYTE;
		}

		#~
		Prints value with newline
		@ignore-params
		~#
		function : PrintLine(b : Byte) ~ Nil {
			STD_OUT_BYTE;
			'\n'->Print();
		}

		#~
		Prints error value
		@ignore-params
		~#
		function : Error(b : Byte) ~ Nil {
			STD_ERR_BYTE;
		}

		#~
		Prints error value with newline
		@ignore-params
		~#
		function : ErrorLine(b : Byte) ~ Nil {
			STD_ERR_BYTE;
			'\n'->Error();
		}

		function : Size(b : Byte[]) ~ Int {
			LOAD_ARY_SIZE;
		}
		
		function : ToUnicode(b : Byte[]) ~ Char[] {
			BYTES_TO_UNICODE;
		}
		
		function : native :  Sort(v : Byte[]) ~ Byte[] {
			size := v->Size();
			if(size <= 1) {
				return v;
			};			
			array := Byte->New[size];
			Runtime->Copy(array, 0, v, 0, size);
			Sort(array, 0, size - 1);
			
			return array;
		}
		
		function : native : Sort(array : Byte[], low : Int, high : Int) ~ Nil {
			i := low; j := high;
			pivot := array[low + (high-low)/2];

			while(i <= j) {
				while(array[i] < pivot) {
					i+=1;
				};
	
				while(array[j] > pivot) {
					j-=1;
				};

				if (i <= j) {
					temp := array[i];
					array[i] := array[j];
					array[j] := temp;
					i+=1; j-=1;
				};
			};
	
			if(low < j) {
				Sort(array, low, j);
			};

			if(i < high) {
				Sort(array, i, high);
			};
		}

		function : Size(b : Byte[,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		function : Size(b : Byte[,,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}
		
		#~
		Returns a binary string representation of the value
		@ignore-params
		@return binary string representation of the value
		~#
		function : native : ToBinaryString(v : Byte) ~ String {
			out := "";
			do {
				out->Append(v and 1 = 0 ? '0' : '1');
				v := v >> 1;
			} 
			while(v <> 0);

			return out->Reverse();
		}

		#~
		Returns a hexadecimal string representation of the value
		@ignore-params
		@return hexadecimal string representation of the value
		~#
		function : native : ToHexString(b : Byte) ~ String {
			buffer := Char->New[16];
			Number->IntToString(b->As(Int), 16, buffer);
			return String->New(buffer);
		}
		
		function : native : ToHexString(b : Byte[]) ~ String {
			out := String->New();
			each(i : b) {
				buffer := Char->New[16];
				Number->IntToString(b[i]->As(Int), 16, buffer);
				out->Append(buffer);
			};
			
			return out;
		}
		
		#~
		Returns a string representation of the value
		@ignore-params
		@return string representation of the value
		~#
		function : native : ToString(b : Byte) ~ String {
			buffer := Char->New[16];
			Number->IntToString(b->As(Int), 10, buffer);
			return String->New(buffer);
		}
		
		function : native : ToString(b : Byte[]) ~ String {
			out := String->New();
			each(i : b) {
				ToString(b[i]);
				out->Append(ToString(b[i]));
			};
			
			return out;
		}
	}

	#~
	Character class represents a Unicode character value.
	~#	
	class $Char {
		#~
		Converts character to lower-case
		@ignore-params
		@return lower-case representation
		~#
		function : native : ToLower(c : Char) ~ Char {
			if(c >= 'A' & c <= 'Z') {
				return c + 32;
			};

			return c;
		}

		function : Size(v : Char) ~ Char {
			return v;
		}

		#~
		Converts character to upper-case
		@ignore-params
		@return upper-case representation
		~#
		function : native : ToUpper(c : Char) ~ Char {
			if(c >= 'a' & c <= 'z') {
				return c - 32;
			};

			return c;
		}
		
		#~
        Returns the Float value
        @ignore-params
        @return value
        ~#
        function : ToFloat(v : Char) ~ Float {
                return v->As(Float);
        }

        #~
        Returns the Character value
        @ignore-params
        @return value
        ~#
        function : ToByte(v : Byte) ~ Byte {
                return v->As(Byte);
        }

        #~
        Returns the Int value
        @ignore-params
        @return value
        ~#
        function : ToInt(v : Char) ~ Int {
                return v->As(Int);
        }
		
		#~
		Checks if the character is lower-case
		@ignore-params
		@return true if lower-case, false otherwise
		~#
		function : native : IsLower(c : Char) ~ Bool {
			if(c >= 'a' & c <= 'z') {
				return true;
			};

			return false;
		}

		#~
		Checks if the character is upper-case
		@ignore-params
		@return true if upper-case, false otherwise
		~#
		function : native : IsUpper(c : Char) ~ Bool {
			if(c >= 'A' & c <= 'Z') {
				return true;
			};

			return false;
		}
		
		#~
		Compares two values
		@param l left compare object
		@param r right compare object
		@return 0 if equal, -1 if types differ, 1 if equal
		~#
		function : native : Compare(l : Char, r : Char) ~ Int {
			if(l < r) {
				return -l;
			}
			else if(l > r) {
				return l;
			};

			return 0;
		}

		#~
		Checks of the character is a numeric digit
		@ignore-params
		@return true if numeric digit, false otherwise
		~#
		function : native : IsDigit(c : Char) ~ Bool {
			if(c >= '0' & c <= '9') {
				return true;
			};
			
			return false;
		}

		#~
		Checks of the character is a alpha digit
		@ignore-params
		@return true if alpha digit, false otherwise
		~#
		function : native : IsChar(c : Char) ~ Bool {
			if((c >= 'a' & c <= 'z') | (c >= 'A' & c <= 'Z')) {
				return true;
			};
			
			return false;
		}
		
		#~
		Returns the smallest byte value
		@param l value to compare
		@param r value to compare
		@return smallest byte value
		~#
		function : native : Min(l : Char, r : Char) ~ Char {
			if(l < r) {
				return l;
			};

			return r;
		}

		#~
		Returns the largest byte value
		@param l value to compare
		@param r value to compare
		@return largest byte value
		~#
		function : native : Max(l : Char, r : Char) ~ Char {
			if(l > r) {
				return l;
			};

			return r;
		}

		#~
		Prints value 
		@ignore-params
		~#
		function : Print(c : Char) ~ Nil {
			STD_OUT_CHAR;
		}

		function : PrintLine(c : Char) ~ Nil {
			STD_OUT_CHAR;
			'\n'->Print();
		}
		
		#~
		Prints value with newline
		@ignore-params
		~#
		function : native :  Sort(c : Char[]) ~ Char[] {
			size := c->Size();
			if(size <= 1) {
				return c;
			};			
			array := Char->New[size];
			Runtime->Copy(array, 0, c, 0, size);
			Sort(array, 0, size - 1);
			
			return array;
		}
		
		function : native : Sort(array : Char[], low : Int, high : Int) ~ Nil {
			i := low; j := high;
			pivot := array[low + (high-low)/2];

			while(i <= j) {
				while(array[i] < pivot) {
					i+=1;
				};
	
				while(array[j] > pivot) {
					j-=1;
				};

				if (i <= j) {
					temp := array[i];
					array[i] := array[j];
					array[j] := temp;
					i+=1; j-=1;
				};
			};
	
			if(low < j) {
				Sort(array, low, j);
			};

			if(i < high) {
				Sort(array, i, high);
			};
		}

		function : native :  Print(c : Char[]) ~ Nil {
			STD_OUT_CHAR_ARY;
		}

		function : native :  PrintLine(c : Char[]) ~ Nil {
			STD_OUT_CHAR_ARY;
			'\n'->Print();
		}

		#~
		Prints error value
		@ignore-params
		~#
		function : Error(c : Char) ~ Nil {
			STD_ERR_CHAR;
		}

		#~
		Prints error value with newline
		@ignore-params
		~#
		function : ErrorLine(c : Char) ~ Nil {
			STD_ERR_CHAR;
			'\n'->Error();
		}

		function : native :  Error(c : Char[]) ~ Nil {
			STD_ERR_CHAR_ARY;
		}

		function : native :  ErrorLine(c : Char[]) ~ Nil {
			STD_ERR_CHAR_ARY;
			'\n'->Error();
		}
		
		function : Size(c : Char[]) ~ Int {
			LOAD_ARY_SIZE;
		}
		
		function : ToBytes(c : Char[]) ~ Byte[] {		
			UNICODE_TO_BYTES;
		}
		
		function : Size(c : Char[,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		function : Size(c : Char[,,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		#~
		Returns a string representation of the value
		@ignore-params
		@return string representation of the value
		~#
		function : native : ToString(c : Char) ~ String {
			string : String := String->New();
			string->Append(c);
			
			return string;
		}
	}
	
	#~
	Integer class represents an operating system long value
	~#
	class $Int {
		#~
		Returns the maximum size of an integer
		@return maximum size of an integer
		~#
		function : native : MaxSize() ~ Int {
			return 2147483647;
		}
		
		#~
		Returns the minimum size of an integer
		@return maximum size of an integer
		~#
		function : native : MinSize() ~ Int {
			return -2147483648;
		}
		
		#~
		Calculates the factorial of existing value
		@ignore-param n
		@return factorial of existing value
		~#
		function : native : Factorial(n : Int) ~ Int {
			result := 1;
			for (i := 1; i <= n; i += 1;) {
				result *= i;
			};

			return result;
		}


		#~
		Models a 50/50 coin flip
		@return random true or false
		}
		function : CoinFlip() ~ Bool {
			return Random(1) % 2 = 0;
		}

		#~
		Returns a random number within the given range
		@param min minimal value
		@param max max value
		@return random number within range
		~#
		function : Random(min : Int, max : Int) ~ Int {
			diff := max - min + 1;
			if(diff <= 0) {
				return min;
			};

			return min + (Float->Random() * 1000000.0)->As(Int) % diff;
		}

		#~
		Returns a random number between 0 and max value
		@param max max value
		@return random number within range
		~#
		function : Random(max : Int) ~ Int {
			max += 1;
			if(max <= 0) {
				return 0;
			};

			return (Float->Random() * 1000000.0)->As(Int) % max;
		}
		
		#~
		Returns the smallest integer value
		@param l value to compare
		@param r value to compare
		@return smallest integer value
		~#
		function : native : Min(l : Int, r : Int) ~ Int {
			if(l < r) {
				return l;
			};

			return r;
		}

		#~
		Compares two values
		@param l left compare object
		@param r right compare object
		@return 0 if equal, -1 if types differ, 1 if equal
		~#
		function : native : Compare(l : Int, r : Int) ~ Int {
			if(l < r) {
				return -l;
			}
			else if(l > r) {
				return l;
			};

			return 0;
		}
	
		#~
		Returns the largest integer value
		@param l value to compare
		@param r value to compare
		@return largest integer value
		~#
		function : native : Max(l : Int, r : Int) ~ Int {
			if(l > r) {
				return l;
			};

			return r;
		}

		#~
		Returns the absolute value
		@ignore-params
		@return absolute value
		~#
		function : native : Abs(v : Int) ~ Int {
			if(v < 0) {
				return v * -1;
			};

			return v;
		}

		function : Size(v : Int) ~ Int {
			return v;
		}

		#~
		Returns the Float value
		@ignore-params
		@return value
		~#
		function : ToFloat(v : Int) ~ Float {
			return v->As(Float);
		}

		#~
		Returns the Character value
		@ignore-params
		@return value
		~#
		function : ToChar(v : Int) ~ Char {
			return v->As(Char);
		}

		#~
		Returns the Byte value
		@ignore-params
		@return value
		~#
		function : ToByte(v : Int) ~ Byte {
			return v->As(Byte);
		}

		#~
		Prints value 
		@ignore-params
		~#
		function : Print(i : Int) ~ Nil {
			STD_OUT_INT;
		}

		#~
		Prints value with newline
		@ignore-params
		~#
		function : PrintLine(i : Int) ~ Nil {
			STD_OUT_INT;
			'\n'->Print();
		}
		
		#~
		Prints error value
		@ignore-params
		~#
		function : Error(i : Int) ~ Nil {
			STD_ERR_INT;
		}

		#~
		Prints error value with newline
		@ignore-params
		~#
		function : ErrorLine(i : Int) ~ Nil {
			STD_ERR_INT;
			'\n'->Error();
		}

		function : Size(i : Int[]) ~ Int {
			LOAD_ARY_SIZE;
		}

		function : Size(i : Int[,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		function : Size(i : Int[,,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		#~
		Returns the binary string value
		@ignore-params
		@return binary string value
		~#
		
		function : native : ToBinaryString(v : Int) ~ String {
			out := "";
			do {
				out->Append(v and 1 = 0 ? '0' : '1');
				v := v >> 1;
			} 
			while(v <> 0);

			return out->Reverse();
		}
		
		#~
		Returns the hex string value
		@ignore-params
		@return hex string value
		~#
		function : native : ToHexString(v : Int) ~ String {
			buffer := Char->New[16];
			Number->IntToString(v->As(Int), 16, buffer);
			return String->New(buffer);
		}
		
		function : native : ToHexString(v : Int[]) ~ String {
			out := String->New();
			each(i : v) {
				buffer := Char->New[16];
				Number->IntToString(v[i]->As(Int), 16, buffer);
				out->Append(buffer);
			};
			
			return out;
		}
		
		function : native :  Sort(v : Int[]) ~ Int[] {
			size := v->Size();
			if(size <= 1) {
				return v;
			};			
			array := Int->New[size];
			Runtime->Copy(array, 0, v, 0, size);
			Sort(array, 0, size - 1);
			
			return array;
		}
		
		function : native : Sort(array : Int[], low : Int, high : Int) ~ Nil {
			i := low; j := high;
			pivot := array[low + (high-low)/2];

			while(i <= j) {
				while(array[i] < pivot) {
					i+=1;
				};
	
				while(array[j] > pivot) {
					j-=1;
				};

				if (i <= j) {
					temp := array[i];
					array[i] := array[j];
					array[j] := temp;
					i+=1; j-=1;
				};
			};
	
			if(low < j) {
				Sort(array, low, j);
			};

			if(i < high) {
				Sort(array, i, high);
			};
		}
		
		#~
		Returns the string value
		@ignore-params
		@return string value
		~#
		function : ToString(v : Int) ~ String {
			buffer := Char->New[16];
			Number->IntToString(v->As(Int), 10, buffer);
			return String->New(buffer);
		}

		#~
		Returns a comma formatted string value
		@ignore-params
		@return string value
		~#
		function : native : ToCommaString(v : Int) ~ String {
			buffer := Char->New[16];
			Number->IntToString(v->As(Int), 10, buffer);
			str := String->New(buffer);

			count := 1;
			comma_str : String := "";
			for(i := str->Size() - 1; i >= 0; i -= 1;) {
				comma_str->Append(str->Get(i));
				if(count % 3 = 0 & count + 1 <= str->Size()) {
					comma_str->Append(',');
				};
				count += 1;
			};

			return comma_str->Reverse();
		}
		
		#~
		Returns a string representation of the value
		@ignore-params
		@return string representation of the value
		~#
		function : native : ToString(v : Int[]) ~ String {
			out := "[";
			each(i : v) {
				buffer := Char->New[16];
				Number->IntToString(v[i]->As(Int), 10, buffer);
				out->Append(buffer);
				if(i + 1 < v->Size()) {
					out->Append(',');
				};
			};
			out->Append(']');
			return out;
		}
	}

	#~
	Float class represents a double-precision floating-point value
	~#	
	class $Float {
		#~
		Value of Pi
		@return value of Pi
		~#
		function : native : Pi() ~ Float {
			return 3.1415926536;
		}

		function : Size(v : Float) ~ Float {
			return v;
		}

		#~
		Value of E
		@return value of E
		~#
		function : native : E() ~ Float {
			return 2.7182818285;
		}	

		#~
		Converts the value into radians
		@ignore-params
		@return radian value
		~#
		function : native : ToRadians(v : Float) ~ Float {
			return v * 3.1415926536 / 180.0;
		}
		
		#~
		Converts the value into degrees
		@ignore-params
		@return degree value
		~#
		function : native : ToDegrees(v : Float) ~ Float {
			return v * 180.0 / 3.1415926536;
		}

        #~
        Returns the Int value
        @ignore-params
        @return value
        ~#
        function : ToInt(v : Float) ~ Int {
                return v->As(Int);
        }

        #~
        Returns the Character value
        @ignore-params
        @return value
        ~#
        function : ToByte(v : Float) ~ Byte {
                return v->As(Byte);
        }

        #~
        Returns the Int value
        @ignore-params
        @return value
        ~#
        function : ToChar(v : Float) ~ Char {
                return v->As(Char);
        }

		#~
		Returns the smallest float value
		@param r value to compare
		@ignore-param l
		@return smallest float value
		~#
		function : native : Min(l : Float, r : Float) ~ Float {
			if(l < r) {
				return l;
			};

			return r;
		}

		#~
		Returns the largest float value
		@param l value to compare
		@param r value to compare
		@return largest float value
		~#
		function : native : Max(l : Float, r : Float) ~ Float {
			if(l > r) {
				return l;
			};

			return r;
		}

		#~
		Compares two value
		@param l left compare object
		@param r right compare object
		@return 0 if equal, -1 if types differ, 1 if equal
		~#
		function : native : Compare(l : Float, r : Float) ~ Int {
			if(l < r) {
				return -l;
			}
			else if(l > r) {
				return l;
			};

			return 0;
		}

		#~
		Returns the absolute value
		@ignore-params
		@return absolute value
		~#
		function : native : Abs(v : Float) ~ Float {
			if(v < 0) {
				return v * -1;
			};

			return v;
		}
		
		#~
		Calculates the floor value
		@ignore-params
		@return floor value
		~#
		function : Floor(f : Float) ~ Float {
			FLOR_FLOAT;
		}
		
		#~
		Calculates the ceiling value
		@ignore-params
		@return ceiling value
		~#
		function : Ceiling(f : Float) ~ Float {
			CEIL_FLOAT;
		}
		
		#~
		Calculates the sine value
		@ignore-params
		@return sine value
		~#
		function : Sin(f : Float) ~ Float {
			SIN_FLOAT;
		}
		
		#~
		Calculates the cosine value
		@ignore-params
		@return cosine value
		~#
		function : Cos(f : Float) ~ Float {
			COS_FLOAT;
		}
		
		#~
		Calculates the tangent value
		@ignore-params
		@return tangent value
		~#
		function : Tan(f : Float) ~ Float {
			TAN_FLOAT;
		}

		#~
		Calculates the arc-sine value
		@ignore-params
		@return arc-sine value
		~#
		function : ArcSin(f : Float) ~ Float {
			ASIN_FLOAT;
		}
		
		#~
		Calculates the cosine value
		@ignore-params
		@return cosine value
		~#
		function : ArcCos(f : Float) ~ Float {
			ACOS_FLOAT;
		}
		
		#~
		Calculates the arc-tangent value
		@ignore-params
		@return arc-tangent value
		~#
		function : ArcTan(f : Float) ~ Float {
			ATAN_FLOAT;
		}
		
		#~
		Calculates arc tangent of y/x
		@param y value
		@param x value
		@return arc-tangent value
		~#
		function : ArcTan2(y : Float, x : Float) ~ Float {
			ATAN2_FLOAT;
		}
		
		#~
		Calculates the log value
		#~
		Calculates the log value
		@ignore-params
		@return log value
		~#
		function : Log(f : Float) ~ Float {
			LOG_FLOAT;
		}
		
		#~
		Calculates the natural log value
		@ignore-params
		@return natural log value
		~#
		function : SquareRoot(f : Float) ~ Float {
			SQRT_FLOAT;
		}
		
		#~
		Returns a pseudo random value between 0.0 and 1.0
		@ignore-params
		@return pseudo random value
		~#
		function : Random() ~ Float {
			RAND_FLOAT;
		}
		
		#~
		Calculates the power value
		@param b power base
		@param r power to raise
		@return pseudo power value
		~#
		function : Power(b : Float, r : Float) ~ Float {
			POW_FLOAT;
		}

		#~
		Prints value 
		@ignore-params
		~#
		function : Print(f : Float) ~ Nil {
			STD_OUT_FLOAT;
		}

		#~
		Prints value with newline
		@ignore-params
		~#
		function : PrintLine(f : Float) ~ Nil {
			STD_OUT_FLOAT;
			'\n'->Print();
		}

		#~
		Prints error value
		@ignore-params
		~#
		function : Error(f : Float) ~ Nil {
			STD_ERR_FLOAT;
		}

		#~
		Prints error value with newline
		@ignore-params
		~#
		function : ErrorLine(f : Float) ~ Nil {
			STD_ERR_FLOAT;
			'\n'->Error();
		}
		
		function : Size(f : Float[]) ~ Int {
			LOAD_ARY_SIZE;
		}

		function : Size(f : Float[,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		function : Size(f : Float[,,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		#~
		Returns a string representation of the value
		@ignore-params
		@return string representation of the value
		~#
		function : native : ToString(f : Float) ~ String {
			buffer := Char->New[16];
			Number->FloatToString(f, buffer);
			return String->New(buffer);
		}

		function : native : ToString(v : Float[]) ~ String {
			out := "[";
			each(i : v) {
				buffer := Char->New[16];
				Number->FloatToString(v[i], buffer);
				out->Append(buffer);
				if(i + i < v->Size()) {
				  out->Append(',');
				};
			};
			out->Append(']');
			return out;
		}
		
		function : ToString(v : Float[,]) ~ String {
			buffer := "";

			dims := v->Size();
			rows := dims[0];
			cols := dims[1];

			for(r := 0; r < rows; r +=1;) {
				buffer->Append('[');
				for(c := 0; c < cols; c +=1;) {
					buffer->Append(v[r,c]);
					if(c + 1 < cols) {
						buffer->Append(", ");
					};
				};

				if(r + 1 < rows) {
					buffer->Append("]\n");
				}
				else {
					buffer->Append(']');
				};
			};

			return buffer;
		}
		
		function : native :  Sort(v : Float[]) ~ Float[] {
			size := v->Size();
			if(size <= 1) {
				return v;
			};			
			array := Float->New[size];
			Runtime->Copy(array, 0, v, 0, size);
			Sort(array, 0, size - 1);
			
			return array;
		}
		
		function : native : Sort(array : Float[], low : Int, high : Int) ~ Nil {
			i := low; j := high;
			pivot := array[low + (high-low)/2];

			while(i <= j) {
				while(array[i] < pivot) {
					i+=1;
				};
	
				while(array[j] > pivot) {
					j-=1;
				};

				if (i <= j) {
					temp := array[i];
					array[i] := array[j];
					array[j] := temp;
					i+=1; j-=1;
				};
			};
	
			if(low < j) {
				Sort(array, low, j);
			};

			if(i < high) {
				Sort(array, i, high);
			};
		}
	}

	# Array class support
	class $BaseArray {
		function : Size(f : System.Base[]) ~ Int {
			LOAD_ARY_SIZE;
		}

		function : Size(f : System.Base[,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}

		function : Size(f : System.Base[,,]) ~ Int[] {
			LOAD_MULTI_ARY_SIZE;
		}
	}

	#~
	Holds a boolean value
	~#
	class BoolHolder implements System.Compare, System.Clone {
		@value : Bool;

		#~
		Default constructor
		~#
		New() {
			Parent();
			@value := false;
		}

		#~
		Copy constructor
		@param value boolean value
		~#
		New(value : Bool) {
			Parent();
			@value := value;
		}

		#~
		Get boolean value
		@return boolean value
		~#
		method : public : Get() ~ Bool {
			return @value;
		}
		
		#~
		Set boolean value
		@param value boolean value		
		~#
		method : public : Set(value : Bool) ~ Nil {
			@value := value;
		}

		#~
		Compares two objects
		@param rhs compare object
		@return 0 if equal, -1 if types differ, 1 if equal
		~#
		method : public : native : Compare(rhs : System.Compare) ~ Int {
			# check class type
			if(GetClassID() <> rhs->GetClassID()) {
				return -1;
			};
			
			right : BoolHolder := rhs->As(BoolHolder);
			if(@value = right->Get()) {
				return 0;
			};
			
			return 1;
		}

		#~
		Clones the object instance
		@return cloned the object instance
		~#
		method : public : Clone() ~ System.Compare {
			return BoolHolder->New(@value);
		}

		#~
		Returns a unique hash ID for a boolean
		@return hash ID
		~#
		method : public : HashID() ~ Int {
			return @value ? 1 : 0;
		}

		method : public : Print() ~ Nil {
			@value->Print();
		}

		method : public : PrintLine() ~ Nil {
			@value->PrintLine();
		}

        method : public : ToString() ~ String {
			return @value->ToString();
		}
	}
	
	#~
	Holds an byte value
	~#
	class ByteHolder implements System.Compare, System.Clone {
		@value : Byte;

		#~
		Default constructor
		~#
		New() {
			Parent();
			@value := 0;
		}

		#~
		Copy constructor
		@param value byte value
		~#
		New(value : Byte) {
			Parent();
			@value := value;
		}

		#~
		Get byte value
		@return byte value
		~#
		method : public : Get() ~ Byte {
			return @value;
		}
		
		#~
		Set byte value
		@param value byte value		
		~#
		method : public : Set(value : Byte) ~ Nil {
			@value := value;
		}

		#~
		Compares two objects
		@param rhs compare object
		@return 0 if equal, -1 if right-hand side i greater, 1 if left-hand side is greater
		~#
		method : public : native : Compare(rhs : System.Compare) ~ Int {
			# check class type
			if(GetClassID() <> rhs->GetClassID()) {
				return -1;
			};
			
			right : ByteHolder := rhs->As(ByteHolder);
			if(@value = right->Get()) {
				return 0;
			}
			else if(@value < right->Get()) {
				return -1;
			};
			
			return 1;
		}

		#~
		Clones the object instance
		@return cloned the object instance
		~#
		method : public : Clone() ~ System.Compare {
			return ByteHolder->New(@value);
		}

		#~
		Returns a unique hash ID for a byte
		@return hash ID
		~#
		method : public : HashID() ~ Int {
			return @value;
		}

		method : public : Print() ~ Nil {
			@value->Print();
		}

		method : public : PrintLine() ~ Nil {
			@value->PrintLine();
		}

        method : public : ToString() ~ String {
			return @value->ToString();
		}
	}

	#~
	Holds an character value
	~#
	class CharHolder implements System.Compare, System.Clone {
		@value : Char;

		#~
		Default constructor
		~#
		New() {
			Parent();
			@value := 0;
		}

		#~
		Copy constructor
		@param value character value
		~#
		New(value : Char) {
			Parent();
			@value := value;
		}

		#~
		Get character value
		@return character value
		~#
		method : public : Get() ~ Char {
			return @value;
		}
		
		#~
		Set character value
		@param value character value		
		~#
		method : public : Set(value : Char) ~ Nil {
			@value := value;
		}

		#~
		Compares two objects
		@param rhs compare object
		@return 0 if equal, -1 if right-hand side i greater, 1 if left-hand side is greater
		~#
		method : public : native : Compare(rhs : System.Compare) ~ Int {
			# check class type
			if(GetClassID() <> rhs->GetClassID()) {
				return -1;
			};
			
			right : CharHolder := rhs->As(CharHolder);
			if(@value = right->Get()) {
				return 0;
			}
			else if(@value < right->Get()) {
				return -1;
			};
			
			return 1;
		}

		#~
		Clones the object instance
		@return cloned the object instance
		~#
		method : public : Clone() ~ System.Compare {
			return CharHolder->New(@value);
		}

		#~
		Returns a unique hash ID for a character
		@return hash ID
		~#
		method : public : HashID() ~ Int {
			return @value;
		}

		method : public : Print() ~ Nil {
			@value->Print();
		}

		method : public : PrintLine() ~ Nil {
			@value->PrintLine();
		}

        method : public : ToString() ~ String {
			return @value->ToString();
		}
	}

	#~
	Holds an integer value
	~#
	class IntHolder implements System.Compare, System.Clone {
		@value : Int;

		#~
		Default constructor
		~#
		New() {
			Parent();
			@value := 0;
		}

		#~
		Copy constructor
		@param value integer value
		~#
		New(value : Int) {
			Parent();
			@value := value;
		}

		#~
		Get integer value
		@return integer value
		~#
		method : public : Get() ~ Int {
			return @value;
		}
		
		#~
		Set integer value
		@param value integer value		
		~#
		method : public : Set(value : Int) ~ Nil {
			@value := value;
		}

		#~
		Increments value by 1
		~#
		method : public : Inc() ~ Nil {
			@value += 1;
		}

		#~
		Adds to value
		@param value value to add to	
		~#
		method : public : Add(value : Int) ~ Nil {
			@value += value;
		}

		#~
		Decrements value by 1
		~#
		method : public : Dec() ~ Nil {
			@value -= 1;
		}

		#~
		Subtract from value
		@param value value to subtract by	
		~#
		method : public : Sub(value : Int) ~ Nil {
			@value -= value;
		}

		#~
		Multiply to value
		@param value value to multiply by	
		~#
		method : public : Mul(value : Int) ~ Nil {
			@value *= value;
		}

		#~
		Divide by value
		@param value value to divide by		
		~#
		method : public : Div(value : Int) ~ Nil {
			@value /= value;
		}
		
		#~
		Compares two objects
		@param rhs compare object
		@return 0 if equal, -1 if right-hand side i greater, 1 if left-hand side is greater
		~#
		method : public : native : Compare(rhs : System.Compare) ~ Int {
			# check class type
			if(GetClassID() <> rhs->GetClassID()) {
				return -1;
			};
			
			right : IntHolder := rhs->As(IntHolder);
			if(@value = right->Get()) {
				return 0;
			}
			else if(@value < right->Get()) {
				return -1;
			};
			
			return 1;
		}

		#~
		Clones the object instance
		@return cloned the object instance
		~#
		method : public : Clone() ~ System.Compare {
			return IntHolder->New(@value);
		}

		#~
		Returns a unique hash ID for a integer
		@return hash ID
		~#
		method : public : HashID() ~ Int {
			return @value;
		}

		method : public : Print() ~ Nil {
			@value->Print();
		}

		method : public : PrintLine() ~ Nil {
			@value->PrintLine();
		}

        method : public : ToString() ~ String {
			return @value->ToString();
		}
	}

	#~
	Holds a float
	~#
	class FloatHolder implements System.Compare, System.Clone {
		@value : Float;

		#~
		Default constructor
		~#
		New() {
			Parent();
			@value := 0.0;
		}

		#~
		Copy constructor 
		@param value float value
		~#
		New(value : Float) {
			Parent();
			@value := value;
		}

		#~
		Get value
		@return value
		~#
		method : public : Get() ~ Float {
			return @value;
		}
		
		#~
		Set value
		@param value float value
		~#
		method : public : Set(value : Float) ~ Nil {
			@value := value;
		}
		
		#~
		Adds to value
		@param value value to add to	
		~#
		method : public : Add(value : Float) ~ Nil {
			@value += value;
		}

		#~
		Subtract from value
		@param value value to subtract by	
		~#
		method : public : Sub(value : Float) ~ Nil {
			@value -= value;
		}

		#~
		Multiply to value
		@param value value to multiply by	
		~#
		method : public : Mul(value : Float) ~ Nil {
			@value *= value;
		}

		#~
		Divide by value
		@param value value to divide by		
		~#
		method : public : Div(value : Float) ~ Nil {
			@value /= value;
		}
		
		#~
		Compares two objects
		@param rhs compare object
		@return 0 if equal, -1 if right-hand side i greater, 1 if left-hand side is greater
		~#
		method : public : native : Compare(rhs : System.Compare) ~ Int {
			# check class type
			if(GetClassID() <> rhs->GetClassID()) {
				return -1;
			};
			
			right : FloatHolder := rhs->As(FloatHolder);
			if(@value = right->Get()) {
				return 0;
			}
			else if(@value < right->Get()) {
				return -1;
			};
			
			return 1;
		}

		#~
		Clones the object instance
		@return cloned the object instance
		~#
		method : public : Clone() ~ System.Compare {
			return FloatHolder->New(@value);
		}
		
		#~
		Returns a unique hash ID for a float
		@return hash ID
		~#
		method : public : HashID() ~ Int {
			return @value * 10000.0;
		}

		method : public : Print() ~ Nil {
			@value->Print();
		}

		method : public : PrintLine() ~ Nil {
			@value->PrintLine();
		}

        method : public : ToString() ~ String {
			return @value->ToString();
		}
	}

	#~
	Holds a byte array
	~#
	class ByteArrayHolder {
		@values : Byte[];

		#~
		Copy constructor 
		@param values byte array 
		~#
		New(values : Byte[]) {
			Parent();
			@values := values;
		}

		#~
		Get values
		@return values
		~#
		method : public : Get() ~ Byte[] {
			return @values;
		}
		
		#~
		Sets values
		@param values byte array 
		~#
		method : public : Set(values : Byte[]) ~ Nil {
			@values := values;
		}
	}

	#~
	Holds a character array
	~#
	class CharArrayHolder {
		@values : Char[];

		#~
		Copy constructor 
		@param values character array 
		~#
		New(values : Char[]) {
			Parent();
			@values := values;
		}

		#~
		Get value
		@return value
		~#
		method : public : Get() ~ Char[] {
			return @values;
		}
		
		#~
		Set value
		@param values character array 
		~#
		method : public : Set(values : Char[]) ~ Nil {
			@values := values;
		}
	}
	
	#~
	Holds an integer array
	~#
	class IntArrayHolder {
		@values : Int[];

		#~
		Copy constructor 
		@param values integer array 
		~#
		New(values : Int[]) {
			Parent();
			@values := values;
		}

		#~
		Get values
		@return values
		~#
		method : public : Get() ~ Int[] {
			return @values;
		}
		
		#~
		Set values
		@param values integer array 
		~#
		method : public : Set(values : Int[]) ~ Nil {
			@values := values;
		}
	}

	#~
	Holds a float array
	~#
	class FloatArrayHolder {
		@values : Float[];

		#~
		Copy constructor 
		@param values float array 
		~#
		New(values : Float[]) {
			Parent();
			@values := values;
		}

		#~
		Gets values
		@return value
		~#
		method : public : Get() ~ Float[] {
			return @values;
		}
		
		#~
		Sets values
		@param values float array 
		~#
		method : public : Set(values : Float[]) ~ Nil {
			@values := values;
		}
	}

	#~
	Holds an base array
	~#
	class BaseArrayHolder {
		@values : Base[];

		#~
		Copy constructor 
		@param values integer array 
		~#
		New(values : Base[]) {
			Parent();
			@values := values;
		}

		#~
		Get values
		@return values
		~#
		method : public : Get() ~ Base[] {
			return @values;
		}
		
		#~
		Set values
		@param values integer array 
		~#
		method : public : Set(values : Base[]) ~ Nil {
			@values := values;
		}
	}
	
	#~
	Holds a function of in/out type R
	~#
	class FuncHolder <R> {
		@func : () ~ R;

		#~
		Constructor
		@param func function
		~#
		New(func : () ~ R) {
			Parent();
			@func := func;
		}

		#~
		Gets function
		@return function
		~#
		method : public : Get() ~ () ~ R {
			return @func;
		}

		#~
		Sets function
		@param func function
		~#
		method : public : Set(func : () ~ R) ~ Nil {
			@func := func;
		}
	}
	
	#~
	Holds a function of in type X and out type R
	~#
	class Func2Holder <X, R> {
		@func : (X) ~ R;

		#~
		Constructor
		@param func function
		~#
		New(func : (X) ~ R) {
			Parent();
			@func := func;
		}

		#~
		Gets function
		@return function
		~#
		method : public : Get() ~ (X) ~ R {
			return @func;
		}

		#~
		Sets function
		@param func function
		~#
		method : public : Set(func : (X) ~ R) ~ Nil {
			@func := func;
		}

		#~
		Apply function
		@param arg argument
		@return applied result
		~#
		function : Apply(arg : X) ~ R {
			return @func(arg);
		}
	}

	#~
	Holds a function of in types X, Y and out type R
	~#
	class Func3Holder <X, Y, R> {
		@func : (X, Y) ~ R;

		#~
		Constructor
		@param func function
		~#
		New(func : (X, Y) ~ R) {
			Parent();
			@func := func;
		}
		
		#~
		Gets function
		@return function
		~#
		method : public : Get() ~ (X, Y) ~ R {
			return @func;
		}

		#~
		Sets function
		@param func function
		~#
		method : public : Set(func : (X, Y) ~ R) ~ Nil {
			@func := func;
		}
	}

	#~
	Holds a function of in types X, Y, Z and out type R
	~#
	class Func4Holder <X, Y, Z, R> {
		@func : (X, Y, Z) ~ R;

		#~
		Constructor
		@param func function
		~#
		New(func : (X, Y, Z) ~ R) {
			Parent();
			@func := func;
		}
		
		#~
		Gets function
		@return function
		~#
		method : public : Get() ~ (X, Y, Z) ~ R {
			return @func;
		}

		#~
		Sets function
		@param func function
		~#
		method : public : Set(func : (X, Y, Z) ~ R) ~ Nil {
			@func := func;
		}
	}

	# Unique ID for each class
	enum ClassID {
	}

	#~
	Base class for all objects
	~#	
	class Base {
		#~
		Default constructor
		~#	
		New() {
		}

		#~
		Returns the class associated with this instance
		@return associated with this instance
		~#	
		method : public : GetClass() ~ Introspection.Class {
			cls : Class;
			LOAD_CLS_BY_INST;
			return cls;
		}
		
		#~
		Returns the unique class ID
		@return unique class ID
		~#
		method : public : native : GetClassID() ~ ClassID {
			LOAD_CLS_INST_ID;
		}

		#~
		Returns the unique instance ID
		@return unique instance ID
		~#
		method : public : native : GetInstanceID() ~ Int {
			LOAD_INST_UID;
		}
	}
	
	#~
	Used to compare two abstract values
	~#	
	interface Compare {
		#~
		Compares two objects
		@param rhs compare object
		@return 0 if equal, -1 if right-hand side i greater, 1 if left-hand side is greater
		~#
		method : virtual : public : Compare(rhs : System.Compare) ~ Int;

		#~
		Returns a hash ID for the given class
		@return hash ID
		~#
		method : virtual : public : HashID() ~ Int;
	}

	#~
	Used to clone objects
	~#
	interface Clone {
		#~
		Clones the object instance
		@return cloned the object instance
		~#
		method : virtual : public : Clone() ~ System.Clone;
	}

	#~
	Provides rudimentary compare functionality 
	~#
	class BasicCompare implements System.Compare {
		#~
		Default constructor
		~#
		New() {
			Parent();
		}

		#~
		Compares two objects
		@param rhs compare object
		@return 0 if equal, -1 if right-hand side i greater, 1 if left-hand side is greater
		~#
		method : public : Compare(rhs : System.Compare) ~ Int {
			if(GetInstanceID() = rhs->GetInstanceID()) {
				return 0;
			}
			else if(GetInstanceID() < rhs->GetInstanceID()) {
				return 1;
			};

			return -1;
		}
		
		#~
		Returns the class default hash ID
		@return hash ID
		~#
		method : public : HashID() ~ Int {
			return GetInstanceID();
		}
	}
	
	#~
	Resizeable Unicode string class that supports typical string operations.
	~#	
	class String implements System.Compare, System.Clone {
		@string : Char[];
		@max : Int;
		@pos : Int;

		#~
		Default constructor
		~#
		New() {
			Parent();

			@max := 8;
			@string := Char->New[@max];
			@pos := 0;
		}

		#~
		Copy constructor
		@param string string to be copied
		~#
		New(string : String) {
			Parent();

			@max := 8;
			@string := Char->New[@max];
			@pos := 0;
			
			if(string <> Nil) {
				Append(string->ToCharArray());
			};
		}
		
		#~
		Copy constructor
		@param array array to be copied
		~#		
		New(array : Char[]) {
			Parent();

			if(array->Size() < 8) {
				@max := 8;
			}
			else {
				@max := array->Size();
			};
			
			@string := Char->New[@max];
			@pos := 0;

			Append(array);
		}
		
		#~
		Copy constructor
		@param array array to be copied
		@param offset offset array index offset
		@param max offset max max number of characters to copy
		~#
		New(array : Char[], offset : Int, max : Int) {
			Parent();

			if(array->Size() < 8) {
				@max := 8;
			}
			else {
				@max := array->Size() - offset;
			};

			@string := Char->New[@max];
			@pos := 0;

			Append(array, offset, max);
		}
		
		#~
		Copy constructor
		@param bytes array to be copied
		~#
		New(bytes : Byte[]) {
			Parent();
			
			array := bytes->ToUnicode();
			if(array->Size() < 8) {
				@max := 8;
			}
			else {
				@max := array->Size();
			};
			
			@string := Char->New[@max];
			@pos := 0;

			Append(array);
		}

		#~
		Copy constructor
		@param bytes array to be copied
		@param offset offset array index offset
		@param max max number of characters to copy
		~#
		New(bytes : Byte[], offset : Int, max : Int) {
			Parent();

			array := bytes->ToUnicode();
			if(array->Size() < 8) {
				@max := 8;
			}
			else {
				@max := array->Size() - offset;
			};

			@string := Char->New[@max];
			@pos := 0;

			Append(array, offset, max);
		}

		#~
		Returns a character array representation of the String
		@return character array
		~#
		method : public : ToCharArray() ~ Char[] {
			array : Char[] := Char->New[@pos];
			Runtime->Copy(array, 0, @string, 0, @pos);
			return array;
		}
		
		#~
		Returns a byte array representation of the String
		@return byte array
		~#
		method : public : native : ToByteArray() ~ Byte[] {
			array : Byte[] := Byte->New[@pos];
			for(i : Int := 0; i < @pos; i += 1;) {
				array[i] := @string[i];
			};

			return array;
		}
		
		#~
		Appends a boolean value
		@param b boolean value
		~#
		method : public : native : Append(b : Bool) ~ Nil {
			if(b) {
				Append("true"->ToCharArray());
			}
			else {
				Append("false"->ToCharArray());
			};
		}

		#~
		Appends a integer value
		@param i integer value
		~#
		method : public : native : Append(i : Int) ~ Nil {
			Append(i->ToString()->ToCharArray());
		}

		#~
		Appends a float value
		@param f float value
		~#
		method : public : native : Append(f : Float) ~ Nil {
			Append(f->ToString()->ToCharArray());
		}

		#~
		Appends a string
		@param str string object
		~#
		method : public : native : Append(str : String) ~ Nil {
			Append(str->ToCharArray());
		}
		
		#~
		Appends a character array
		@param array character array
		~#
		method : public : native : Append(array : Char[]) ~ Nil {
			if(@pos + array->Size() >= @max) {
				# expand string
				@max := (@max + array->Size()) * 2;
				tmp : Char[] := Char->New[@max];
				# copy elements				
				Runtime->Copy(tmp, 0, @string, 0, @string->Size());
				@string := tmp;
			};
			
			max := array->Size();
			for(i : Int := 0; i < max & array[i] <> '\0'; i += 1;) {
				@string[@pos] := array[i];
				@pos += 1;
			};
		}

		#~
		Appends a portion of character array
		@param array array to be copied
		@param offset offset array index offset
		@param max max number of characters to copy
		~#
		method : public : native : Append(array : Char[], offset : Int, max : Int) ~ Nil {
			if(offset < 0) {
				return;
			};
			
			if(@pos + max >= @max) {
				# expand string
				@max := (@max + max) * 2;
				tmp : Char[] := Char->New[@max];
				# copy elements
				Runtime->Copy(tmp, 0, @string, 0, @string->Size());
				@string := tmp;
			};

			end := offset + max;
			for(i : Int := offset; i < end & array[i] <> '\0'; i += 1;) {
				@string[@pos] := array[i];
				@pos += 1;
			};
		}
		
		#~
		Appends a character array
		@param array array to be copied
		~#
		method : public : native : Append(array : Byte[]) ~ Nil {
			if(@pos + array->Size() >= @max) {
				# expand string
				@max := (@max + array->Size()) * 2;
				tmp : Char[] := Char->New[@max];
				# copy elements
				Runtime->Copy(tmp, 0, @string, 0, @string->Size());
				@string := tmp;
			};
			
			max := array->Size();
			for(i : Int := 0; i < max & array[i] <> '\0'; i += 1;) {
				@string[@pos] := array[i];
				@pos += 1;
			};
		}

		#~
		Appends a portion of byte array
		@param array array to be copied
		@param offset offset array index offset
		@param max max number of bytes to copy
		~#
		method : public : native : Append(array : Byte[], offset : Int, max : Int) ~ Nil {
			if(offset < 0) {
				return;
			};
			
			if(@pos + max >= @max) {
				# expand string
				@max := (@max + max) * 2;
				tmp : Char[] := Char->New[@max];
				# copy elements
				Runtime->Copy(tmp, 0, @string, 0, @string->Size());
				@string := tmp;
			};

			end := offset + max;
			for(i : Int := offset; i < end & array[i] <> '\0'; i += 1;) {
				@string[@pos] := array[i];
				@pos += 1;
			};
		}

		#~
		Appends a character
		@param c character to append
		~#
		method : public : native : Append(c : Char) ~ Nil {
			if(@pos >= @max) {
				# expand string
				@max := @max * 2;
				tmp : Char[] := Char->New[@max];
				# copy elements
				Runtime->Copy(tmp, 0, @string, 0, @string->Size());
				@string := tmp;
			};

			@string[@pos] := c;
			@pos += 1;
		}
		
		#~
		Appends a byte
		@param c byte to append
		~#
		method : public : native : Append(c : Byte) ~ Nil {
			if(@pos >= @max) {
				# expand string
				@max := @max * 2;
				tmp : Char[] := Char->New[@max];
				# copy elements
				Runtime->Copy(tmp, 0, @string, 0, @string->Size());
				@string := tmp;
			};

			@string[@pos] := c;
			@pos += 1;
		}
		
		#~
		Searches for the first occurrence of a character
		@param char character to search for
		@return index of first occurrence, -1 otherwise
		~#
		method : public : Find(char : Char) ~ Int {
			return Find(0, char);
		}

		#~
		Count the occurrences of the character
		@param char character to search for
		@return number of occurrences
		~#
		method : public : Count(char : Char) ~ Int {
			count := 0;
			
			for(i := 0; i < @pos; i += 1;) {
				if(@string[i] = char) {
					count += 1;
				};
			};

			return count;
		}
		
		#~
		Searches for the first occurrence of a character
		@param char character to search for
		@return true of found, false otherwise
		~#
		method : public : Has(char : Char) ~ Bool {
			return Find(0, char) > -1;
		}

		#~
		Searches for the first occurrence of a character
		@param offset search offset
		@param char character to search for
		@return true of found, false otherwise
		~#
		method : public : Has(offset : Int, char : Char) ~ Bool {
			return Find(offset, char) > -1;
		}


		#~
		Searches for the first occurrence of a character
		@param str string to search for
		@return true of found, false otherwise
		~#
		method : public : Has(str : String) ~ Bool {
			return Find(0, str) > -1;
		}

		#~
		Searches for the first occurrence of a character
		@param offset search offset
		@param str string to search for
		@return true of found, false otherwise
		~#
		method : public : Has(offset : Int, str : String) ~ Bool {
			return Find(offset, str) > -1;
		}
			
		#~
		Searches for the first occurrence of a character
		@param offset search offset
		@param char character to search for
		@return index of first occurrence, -1 otherwise
		~#
		method : public : native : Find(offset : Int, char : Char) ~ Int {
			if(offset < @pos & offset > -1) {
				for(i := offset; i < @pos; i += 1;) {
					if(@string[i] = char) {
						return i;
					};
				};
			};

			return -1;
		}
		
		#~
		Searches for the last occurrence of a character
		@param char character to search for
		@return index of last occurrence, -1 otherwise
		~#
		method : public : FindLast(char : Char) ~ Int {
			return FindLast(@pos - 1, char);
		}
		
		#~
		Searches for the last occurrence of a character
		@param offset search offset
		@param char character to search for
		@return index of last occurrence, -1 otherwise
		~#
		method : public : native : FindLast(offset : Int, char : Char) ~ Int {
			if(offset < @pos & offset > -1) {
				for(i := offset; i > -1; i -= 1;) {
					if(@string[i] = char) {
						return i;
					};
				};
			};

			return -1;
		}

		#~
		Searches for the first occurrence of a string
		@param find string to search for
		@return index of first occurrence, -1 otherwise
		~#
		method : public : Find(find : String) ~ Int {
			return Find(0, find);
		}

		#~
		Searches for all occurrences of a string
		@param find string to search for
		@return an array of indexes
		~#
		method : public : FindAll(find : String) ~ Int[] {
			buffer_max := 8;
			buffer := Int->New[buffer_max];
			
			count := 0;
			offset := 0;
			do {
				# check
				offset := Find(offset, find);
				# found
				if(offset > -1) {
					count += 1;
					if(count < buffer_max) {
						buffer[count - 1] := offset;
					}
					# copy elements
					else {
						temp := Int->New[buffer_max * 2];
						Runtime->Copy(temp, 0, buffer, 0, buffer_max);
						buffer_max *= 2;
						buffer := temp;
					};
					offset += find->Size();
				};
			}
			while(offset > -1);
			
			results := Int->New[count];
			each(i : results) {
				results[i] := buffer[i];
			};

			return results;
		}

		#~
		Searches for the first occurrence of a string
		@param offset search index offset
		@param find string to search for
		@return index of first occurrence, -1 otherwise
		~#
		method : public : native : Find(offset : Int, find : String) ~ Int {
			size := find->Size();
			if(size > 0 & offset < @pos) {
				found_index := Find(offset, find->Get(0));
				while(found_index > -1) {
					j := found_index;
					match := true;
					i : Int;
					for(i := 0; match & i < find->Size() & j < @pos; i += 1;) {
						if(find->Get(i) <> @string[j]) {
							match := false;
						};
						j += 1;
					};

					if(match & i = find->Size()) {
						return found_index;
					};
					
					found_index := Find(found_index + 1, find->Get(0));
				};

				return -1;
			};

			return -1;
		}
		
		#~
		Replaces all occurrences the search string
		@param find string to search for
		@param replace string to replace with
		@return new string instance
		~#
		method : public : native : ReplaceAll(find : String, replace : String) ~ String {
			last := @self;
			result := last->Replace(find, replace);
			while(result <> last) {
				last := result;
				result := last->Replace(find, replace);
			};
			
			return result;
		}

		#~
		Replaces all occurrences the search string
		@param find character to search for
		@param replace character to replace with
		@return new string instance
		~#
		method : public : native : ReplaceAll(find : Char, replace : Char) ~ String {
			buffer := "";

			for(i := 0; i < @pos; i += 1;) {
				char := @string[i];
				if(char = find) {
					buffer->Append(replace);
				}
				else {
					buffer->Append(char);
				};
			};

			return buffer;
		}
		
		#~
		Replaces the first occurrence the search string
		@param find string to search for
		@param replace string to replace with
		@return new string instance
		~#
		method : public : native : Replace(find : String, replace : String) ~ String {
			index := Find(find);
			if(index < 0) {
				return @self;
			};
			
			begin := SubString(0, index);
			new_string := String->New(begin);
			index += find->Size();
			length := Size() - index;
			
			if(length = 0) {
				new_string->Append(replace);
			}
			else {
				end := SubString(index, length);
				if(end = Nil) {
					return @self;
				};
				new_string->Append(replace);
				new_string->Append(end);
			};
			
			return new_string;
		}
		
		#~
		Deletes the character at the given index
		@param index delete index
		@return true if deleted, false otherwise 
		~#
		method : public : native : Delete(index : Int) ~ Bool {
			if(index < 0 | index >= @pos) {
				return false;
			};
			
			size := @pos - 1;
			tmp : Char[] := Char->New[size];
			Runtime->Copy(tmp, 0, @string, 0, index);
			Runtime->Copy(tmp, index, @string, index + 1, @pos - index - 1);
			
			@string := tmp;
			@pos := size;
			@max := @pos;
			
			return true;
		}

		#~
		Deletes the characters at the given range
		@param start start index
		@param end end index
		@return true if deleted, false otherwise 
		~#
		method : public : native : Delete(start : Int, end : Int) ~ Bool {
			if(start < 0 | start >= @pos | end < 0 | end >= @pos | start >= end) {
				return false;
			};

			length := end - start + 1;
			size := @pos - length;
			tmp : Char[] := Char->New[size];
			Runtime->Copy(tmp, 0, @string, 0, start);
			Runtime->Copy(tmp, start, @string, end + 1, size - start);

			@string := tmp;
			@pos := size;
			@max := @pos;
			
			return true;
		}

		#~
		Insert inserts a string
		@param index insert offset
		@param s string to insert
		@return true if inserted, false otherwise 
		~#
		method : public : native : Insert(index : Int, s : String) ~ Bool {
			if(index < 0 | index > @pos) {
				return false;
			};
			
			size := @pos + s->Size();
			tmp : Char[] := Char->New[size];
			Runtime->Copy(tmp, 0, @string, 0, index);

			buf := s->ToCharArray();
			Runtime->Copy(tmp, index, buf, 0, buf->Size());

			Runtime->Copy(tmp, index + buf->Size(), @string, index, @pos - index);

			@string := tmp;
			@pos := size;
			@max := @pos;
			
			return true;

		}

		#~
		Returns rather the string is empty
		@return true if empty, false otherwise 
		~#
		method : public : native : IsEmpty() ~ Bool {
			return @pos = 0 ? true : false; 			
		}

		#~
		Clears string
		~#
		method : public : Clear() ~ Nil {
			if(@max > 8 | @max < 1) {
				@max := 8;
				@string := Char->New[@max];
			}
			else {
				@string[0] := '\0';
				@pos := 0;
			};
			@pos := 0;			
		}

		#~
		Return the size of the string
		@return size of the string
		~#
		method : public : native : Size() ~ Int {
			return @pos;			
		}
  
		#~
		Returns character at the given index
		@param index index offset
		@return character at index
		~#
		method : public : native : Get(index : Int) ~ Char {
			if(index > -1 & index < @pos) {
				return @string[index];
			};

			return '\0';
		}

		#~
		Sets character at the given index
		@param char charter to set
		@param index index offset
		@return true if successful, false otherwise
		~#
		method : public : native : Set(char : Char, index : Int) ~ Bool {
			if(index > -1 & index < @pos) {
				@string[index] := char;
			};

			return false;
		}

		#~
		Pops the last character from the string reducing the
		size by 1
		@return last character of the string
		~#
		method : public : native : Pop() ~ Char {
			if(@pos > 0) {
				@pos -= 1;
				c := @string[@pos];
				@string[@pos] := '\0';
				return c;
			};

			return '\0';
		}
		
		#~
		Parses the string into an integer
		@return integer value
		~#
		method : public : ToInt() ~ Int {
			return ToInt(10);
		}

		#~
		Parses the string into an integer
		@param base base radix 
		@return integer value
		~#
		method : public : ToInt(base : Int) ~ Int {
			S2I;
		}

		#~
		Parses the string into a float
		@return float value
		~#
		method : public : ToFloat() ~ Float {
			S2F;
		}

		#~
		Checks if the string starts with the given character
		@param c character to compare
		@return true if starts with character, false otherwise
		~#
		method : public : native : StartsWith(c : Char) ~ Bool {
			sc : Char := Get(0);
			return sc <> '\0' & c = sc;
		}
		
		#~
		Checks if the string ends with the given character
		@param c character to compare
		@return true if ends with character, false otherwise
		~#
		method : public : native : EndsWith(c : Char) ~ Bool {
			if(@pos > 0) {
				sc := @string[@pos - 1];
				return sc <> '\0' & c = sc;
			};
			
			return false;
		}

		#~
		Checks if the string starts with the given string
		@param s string to check for
		@return true if starts with string, false otherwise
		~#
		method : public : native : StartsWith(s : String) ~ Bool {
			if(s->Size() <= @pos) {
				for(i := 0; i < s->Size(); i += 1;) {
					if(s->Get(i) <> @string[i]) {
						return false;
					};
				};

				return true;
			};

			return false;
		}

		#~
		Checks if the string ends with the given character
		@param s string to check for
		@return true if ends with character, false otherwise
		~#
		method : public : native : EndsWith(s : String) ~ Bool {
			if(s->Size() <= @pos) {
				i := s->Size() - 1;
				j := @pos - 1;
				while(i > -1) {
					if(s->Get(i) <> @string[j]) {
						return false;
					};
					i := i - 1;
					j := j - 1;
				};

				return true;
			};

			return false;
		}
		
		#~
		Reverses a string
		@return reversed string 
		~#
		method : public : native : Reverse() ~ String {
			tmp : Char[] := Char->New[@max];
			i := 0; j := @pos - 1;
			while(j > -1) {
				tmp[i] := @string[j];
				j -= 1;	i += 1;
			};
			
			return String->New(tmp);
		}
		
		#~
		Removes all leading and ending white space
		@return trimmed string
		~#
		method : public : native : Trim() ~ String {
			if(@pos = 0) {
				return "";
			};

			start := 0;
			c := @string[start];
			while(start < @pos & (c = ' ' | c = '\t' | c = '\r' | c = '\n' | c = 0xa0 | c = 0x1680 | 
					c >= 0x2000 & c <= 0x200a | c >= 0x000a & c <= 0x000d | c = 0x202f | 
					c = 0x205f | c = 0x3000 | c = 0x0085 | c = 0x2029)) {
				start += 1;
				c := @string[start];
			};

			end := @pos;
			do {
				end -= 1;
			}
			while(end > -1 & (@string[end] = ' ' | @string[end] = '\t' | @string[end] = '\r' | @string[end] = '\n' |
				@string[end] = 0xa0 | @string[end] = 0x1680 | @string[end] >= 0x2000 & @string[end] <= 0x200a | 
				@string[end] >= 0x000a & @string[end] <= 0x000d | @string[end] = 0x202f | @string[end] = 0x205f | 
				@string[end] = 0x3000 | @string[end] = 0x0085 | @string[end] = 0x2029));

			if(end < start) {
				return "";
			};
	
			return String->New(@string, start, end - start + 1);
		}
		
		#~
		Splits a string based upon delimiter
		@param delim splitting delimiter
		@return array of split sub strings 
		~#
		method : public : native : Split(delim : String) ~ String[] {
			if(delim->Size() = 0 | @pos = 0) {
				return Nil;
			};
			
			# first-pass count tokens
			count := 0;
			start_index := 0;
			found_index := -1;
			delim_index := 0;
			
			for(i : Int := 0; i < @pos; i += 1;) {
				if(found_index = -1 & delim->Get(0) = @string[i]) {
					found_index := i;
				};
				
				if(found_index > -1) {
					if(delim_index < delim->Size() & delim->Get(delim_index) = @string[i]) {
						delim_index += 1;
					}
					else if(delim_index = delim->Size()) {
						count += 1;
						start_index := found_index + delim->Size();
						found_index := -1;
						delim_index := 0;
					}
					else {
						found_index := -1;
						delim_index := 0;
					};
				};
			};
			
			if(start_index <> 0) {
				count += 1;
				SubString(start_index, @pos - start_index);
			};
			
			# second-pass parse tokens
			parsed_strings : String[] := String->New[count];
			count := 0;
			start_index := 0;
			found_index := -1;
			delim_index := 0;
			
			for(i : Int := 0; i < @pos; i += 1;) {
				if(found_index = -1 & delim->Get(0) = @string[i]) {
					found_index := i;
				};
				
				if(found_index > -1) {
					if(delim_index < delim->Size() & delim->Get(delim_index) = @string[i]) {
						delim_index += 1;
					}
					else if(delim_index = delim->Size()) {
						parsed_strings[count] := SubString(start_index, found_index - start_index);
						count += 1;
						
						start_index := found_index + delim->Size();
						found_index := -1;
						delim_index := 0;
					}
					else {
						found_index := -1;
						delim_index := 0;
					};
				};
			};
			
			if(start_index <> 0) {
				parsed_strings[count] := SubString(start_index, @pos - start_index);
				count += 1;
			};
			
			return parsed_strings;
		}
		
		#~
		Transforms a to upper case
		@return upper case string
		~#
		method : public : native : ToUpper() ~ String {
			array : Char[] := Char->New[@pos];
			for(i : Int := 0; i < @pos; i += 1;) {
				c := @string[i];
				if(c > 96 & c < 123) {
					c := c - 32;
				};
				array[i] := c;
			};
			
			return String->New(array);
		}
		
		#~
		Transforms a to lower case
		@return lower case string
		~#
		method : public : native : ToLower() ~ String {
			array : Char[] := Char->New[@pos];
			for(i : Int := 0; i < @pos; i += 1;) {
				c := @string[i];
				if(c > 64 & c < 91) {
					c := c + 32;
				};
				array[i] := c;
			};
			
			return String->New(array);
		}

		#~
		Creates a sub-string
		@param length max length of sub-string
		@return sub-string
		~#
		method : public : SubString(length : Int) ~ String {
			return SubString(0, length);
		}

		#~
		Creates a sub-string
		@param offset index offset
		@param length max length of sub-string
		@return sub-string
		~#
		method : public : SubString(offset : Int, length : Int) ~ String {
			if(offset < 0 | offset > @pos) {
				return Nil;
			};

			end : Int := length + offset;
			if(end < 0 | end > @pos) {
				return Nil;
			};

			array : Char[] := Char->New[length];
			if(<>Runtime->Copy(array, 0, @string, offset, length)) {
				return Nil;
			};

			return String->New(array);
		}
	
		#~
		Compares two strings
		@param rhs string to compare
		@return 0 if equal, -1 if right-hand side i greater, 1 if left-hand side is greater
		~#
		method : public : Equals(rhs : String) ~ Bool {
			return Compare(rhs->As(System.Compare)) = 0;
		}

		#~
		Returns a unique hash ID for a given string sequence
		@return hash ID
		~#
		method : public : native : HashID() ~ Int {
			hash := 0;
			for(i := 0; i < @pos; i += 1;) {
				c := @string[i];
				hash += c * 101;
			};
			
			return hash;
		}

		#~
		Compares two objects
		@param rhs compare object
		@return 0 if equal, -1 if right-hand side i greater, 1 if left-hand side is greater
		~#
		method : public : Compare(rhs : System.Compare) ~ Int {
			# check class type
			if(GetClassID() <> rhs->GetClassID()) {
				return -1;
			};
						
			# check each character
			right_string := rhs->As(String);
			for(i := 0; i < @pos; i += 1;) {
				left := @string[i];
				right := right_string->Get(i);
				if(left > right) {
					return 1;
				}
				else if(left < right) {
					return -1;
				};
			};
			
			# check length
			if(@pos > right_string->Size()) {
				return 1;
			};
			
			if(@pos < right_string->Size()) {
				return -1;
			};
			
			# equal
			return 0;
		}

		#~
		Clones the object instance
		@return cloned the object instance
		~#
		method : public : Clone() ~ System.Compare {
			return String->New(@string);
		}

		#~
		Print a string
		~#
		method : public : native : Print() ~ Nil {
			@string->Print();
		}

		#~
		Print a string with a newline
		~#
		method : public : native : PrintLine() ~ Nil {
			@string->PrintLine();
		}

		#~
		Print an error string
		~#
		method : public : native : Error() ~ Nil {
			@string->Error();
		}

		#~
		Print an error string with a newline
		~#
		method : public : native : ErrorLine() ~ Nil {
			@string->ErrorLine();
		}
	}
	
	#~
	Provides access to runtime system
	~#	
	class Runtime {
		#~
		Causes the executing program to halt
		@param code exit code
		~#
		function : Exit(code : Int) ~ Nil {
			EXIT;
		}

		#~
		Executes a system command
		@param n system command
		@return command status code
		~#
		function : Command(n : System.String) ~ Int {
			SYS_CMD;
		}

		#~
		Executes a system command
		@param n system command
		@return output from command
		~#
		function : CommandOutput(n : System.String) ~ System.String[] {
			SYS_CMD_OUT;
		}
		
		#~
		Asserts runtime value to be true. If false,
		program exits with stack trace.
		@param assert value to assert
		~#
		function : Assert(assert : Bool) ~ Nil {
			ASSERT_TRUE;
		}
		
		#~
		Returns an OS platform string
		@return OS platform string
		~#
		function : GetPlatform() ~ String {
			GET_PLTFRM;
		}

		#~
		Returns the package version string
		@return package version string
		~#
		function : GetVersion() ~ String {
			GET_VERSION;
		}

		#~
		Returns the system's temporary directory
		@return system's temporary directory
		~#
		function : GetTempDir() ~ String {
			return GetProperty("tmp_dir");
		}

		#~
		Returns the current user's working directory
		@return current user's working directory
		~#
		function : GetUserDir() ~ String {
			return GetProperty("user_dir");
		}
		
		#~
		Returns the installation directory
		@return installation directory
		~#
		function : GetInstallDir() ~ String {
			return GetProperty("install_dir");
		}
		
		#~
		Fetches a runtime property. System properties include: 'user_dir', tmp_dir and 'install_dir'.
		@param key property key
		@return runtime property 
		~#
		function : GetProperty(key : String) ~ String {
			GET_SYS_PROP;
		}
		
		#~
		Set floating point display precision. Valid values are a number, 'fixed' or 'scientific'.
		@param value property value
		~#
		function : SetPrecision(value : String) ~ Nil {
			SetProperty("precision", value);
		}

		#~
		Sets a runtime property 
		@param key property key
		@param value property value
		~#
		function : SetProperty(key : String, value : String) ~ Nil {
			SET_SYS_PROP;
		}
		
		#~
		Returns the current time
		@param gmt true of time is in GMT, false for system time zone
		@return current time
		~#
		function : GetTime(gmt : Bool) ~ Time.Date {
			return Time.Date->New(gmt);
		}
		
		#~
		Copies data between two byte arrays
		@param dest destination array
		@param dest_offset destination array copy offset
		@param src source array
		@param src_offset source array copy offset
		@param len number of bytes to copy
		@return true if successful, false otherwise
		~#
		function : Copy(dest : Byte[], dest_offset : Int, src : Byte[], src_offset : Int, len : Int) ~ Bool {
			CPY_BYTE_ARY;
		}
		
		#~
		Copies data between two character arrays
		@param dest destination array
		@param dest_offset destination array copy offset
		@param src source array
		@param src_offset source array copy offset
		@param len number of characters to copy
		@return true if successful, false otherwise
		~#
		function : Copy(dest : Char[], dest_offset : Int, src : Char[], src_offset : Int, len : Int) ~ Bool {
			CPY_CHAR_ARY;
		}
		
		#~
		Copies data between two integer arrays
		@param dest destination array
		@param dest_offset destination array copy offset
		@param src source array
		@param src_offset source array copy offset
		@param len number of values to copy
		@return true if successful, false otherwise
		~#
		function : Copy(dest : Int[], dest_offset : Int, src : Int[], src_offset : Int, len : Int) ~ Bool {
			CPY_INT_ARY;
		}
		
		#~
		Copies data between two Base arrays
		@param dest destination array
		@param dest_offset destination array copy offset
		@param src source array
		@param src_offset source array copy offset
		@param len number of values to copy
		@return true if successful, false otherwise
		~#
		function : Copy(dest : Base[], dest_offset : Int, src : Base[], src_offset : Int, len : Int) ~ Bool {
			CPY_INT_ARY;
		}
		
		#~
		Copies data between two Compare arrays
		@param dest destination array
		@param dest_offset destination array copy offset
		@param src source array
		@param src_offset source array copy offset
		@param len number of values to copy
		@return true if successful, false otherwise
		~#
		function : Copy(dest : Compare[], dest_offset : Int, src : Compare[], src_offset : Int, len : Int) ~ Bool {
			CPY_INT_ARY;
		}
		
		#~
		Copies data between two float arrays
		@param dest destination array
		@param dest_offset destination array copy offset
		@param src source array
		@param src_offset source array copy offset
		@param len number of values to copy
		@return true if successful, false otherwise
		~#
		function : Copy(dest : Float[], dest_offset : Int, src : Float[], src_offset : Int, len : Int) ~ Bool {
			CPY_FLOAT_ARY;
		}
	}
}

#~
System API Bundle
~#
bundle System.API {
	#~
	Class allow programmers to load native shared 
	libraries that can be called by Objeck classes. 
	Programmers can call native C functions within these 
	libraries.
	~#	
	class DllProxy {
		@name : String;
		@ptr : Int;
		
		#~
		Path to the shared library. The path should not include the 
		extension name (i.e. .dll, .so, etc.) for platform portability
		@param name shared library path
		~#
		New(name : String) {
			Parent();

			@name := name;
			DLL_LOAD;
		}
		
		#~
		Returns rather the shared library has been successfully loaded
		@return returns true if the the library has been successfully loaded, false otherwise
		~#
		method : public : IsLoaded() ~ Bool {
			return @ptr <> 0;
		}
		
		#~
		Unloads the shared library
		~#
		method : public : Unload() ~ Nil {
			DLL_UNLOAD;
		}
		
		#~
		Calls a native C function.
		@param name of the native C function
		@param args argument to the native function
		~#
		method : public : CallFunction(name : String, args : Base[]) ~ Nil {
			DLL_FUNC_CALL;
		}
	}
}

#~
Provides support for dates and times
~#	
bundle System.Time {	
	#~
	Provides date and time functionality 
	~#	
	class Date implements System.Compare, System.Clone {
		@day : Int;
		@month : Int;
		@year : Int;
		@hours : Int;
		@mins : Int;
		@secs : Int;
		@is_savings : Bool;
		@week_day : Int;
		@is_gmt : Bool;
		
		#~
		Default constructor 
		~#
		New() {
			Parent();
			SYS_TIME;
		}

		#~
		Constructor 
		@param gmt true of time is in GMT, false for system time zone
		~#
		New(gmt : Bool) {
			Parent();
			if(gmt) {
				GMT_TIME;
			}
			else {
				SYS_TIME;
			};
		}
		
		#~
		Constructor, sets time to midnight of the given day
		@param day day of month
		@param month day of year
		@param year year
		@param gmt true of time is in GMT, false for system time zone
		~#
		New(day : Int, month : Int, year : Int, gmt : Bool) {
			Parent();
			DATE_TIME_SET_1;
		}

		#~
		Compares two dates
		@param rhs compare date
		@return 0 if equal, -1 if right-hand side i greater, 1 if left-hand side is greater
		~#
		method : public : Compare(rhs : System.Compare) ~ Int {
			# check class type
			if(GetClassID() <> rhs->GetClassID()) {
				return -1;
			};
						
			# check dates
			right_date := rhs->As(Date);
			if(@year > right_date->GetYear()) {
				return 1;
			}
			else if(@year < right_date->GetYear()) {
				return -1;
			}
			else if(@month > right_date->GetMonth()) {
				return 1;
			}
			else if(@month < right_date->GetMonth()) {
				return -1;
			}
			else if(@day > right_date->GetDay()) {
				return 1;
			}
			else if(@day < right_date->GetDay()) {
				return -1;
			}
			else if(@hours > right_date->GetHours()) {
				return 1;
			}
			else if(@hours < right_date->GetHours()) {
				return -1;
			}
			else if(@mins > right_date->GetMinutes()) {
				return 1;
			}
			else if(@mins < right_date->GetMinutes()) {
				return -1;
			}
			else if(@secs > right_date->GetSeconds()) {
				return 1;
			}
			else if(@secs < right_date->GetSeconds()) {
				return -1;
			};
			
			return 0;
		}

		#~
		Clones the object instance
		@return cloned the object instance
		~#
		method : public : Clone() ~ System.Compare {
			return System.Time.Date->New(@day, @month, @year, @hours, @mins, @secs, @is_gmt);
		}

		#~
		Returns a hash ID for the given class
		@return hash ID
		~#
		method : public : HashID() ~ Int {
			return ToString()->HashID();
		}
		
		#~
		Constructor 
		@param day day of month
		@param month day of year
		@param year year
		@param hours hours
		@param mins minutes
		@param secs seconds
		@param gmt true of time is in GMT, false for system time zone
		~#
		New(day : Int, month : Int, year : Int, hours : Int, mins : Int, secs : Int, gmt : Bool) {
			Parent();
			DATE_TIME_SET_2;
		}

		#~
		Returns the day
		@return day
		~#
		method : public : GetDay() ~ Int {
			return @day;
		}

		#~
		Returns name of the day
		@return name of the day
		~#
		method : public : GetDayName() ~ String {
			days_of_week := ["Sunday", "Monday", "Tuesday", "Wednesday","Thursday","Friday","Saturday"];
			if(@week_day > -1 & @week_day < days_of_week->Size()) {
				return days_of_week[@week_day];
			};

			return "";
		}
		
		#~
		Returns the month 
		@return month
		~#
		method : public : GetMonth() ~ Int {
			return @month;
		}
		
		#~
		Returns name of the month
		@return name of the month
		~#
		method : public : GetMonthName() ~ String {
			days_of_month := ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
			if(@month > -1 & @month - 1 < days_of_month->Size()) {
				return days_of_month[@month - 1];
			};

			return "";
		}

		#~
		Returns the year 
		@return year
		~#
		method : public : GetYear() ~ Int {
			return @year;
		}
		
		#~
		Returns the hours 
		@return hours
		~#
		method : public : GetHours() ~ Int {
			return @hours;
		}
		
		#~
		Returns the minutes  
		@return minutes
		~#
		method : public : GetMinutes() ~ Int {
			return @mins;
		}
		
		#~
		Returns the seconds  
		@return seconds
		~#
		method : public : GetSeconds() ~ Int {
			return @secs;
		}

		#~
		Add days to the date
		@param value days to add
		~#
		method : public : AddDays(value : Int) ~ Nil {
			DATE_TIME_ADD_DAYS;
		}

		#~
		Add hours to the date
		@param value hours to add
		~#
		method : public : AddHours(value : Int) ~ Nil {
			DATE_TIME_ADD_HOURS;
		}
   
		#~
		Add minutes to the date
		@param value minutes to add
		~#
		method : public : AddMinutes(value : Int) ~ Nil {
			DATE_TIME_ADD_MINS;
		}

		#~
		Add seconds to the date
		@param value seconds to add
		~#
		method : public : AddSeconds(value : Int) ~ Nil {
			DATE_TIME_ADD_SECS;
		}

		#~
		Creates a string representation of the date
		@return string representation of the date
		~#
		method : public : ToString() ~ String {
			out := String->New();

			out->Append(GetDayName());
			out->Append(", ");
			out->Append(GetMonthName());
			out->Append(" ");
			out->Append(@day);
			out->Append(", ");
			out->Append(@year);
			out->Append(" ");

			is_am := true;
			if(@hours = 0) {
				out->Append(12);
			}
			else if(@hours = 12) {
				out->Append(12);
				is_am := false;
			}
			else if(@hours > 12) {
				out->Append(@hours - 12);
				is_am := false;
			}
			else {
				out->Append(@hours);
			};

			out->Append(":");
			if(@mins < 10) {
				out->Append('0');
			};
			out->Append(@mins);

			out->Append(":");
			if(@secs < 10) {
				out->Append('0');
			};
			out->Append(@secs);

			if(is_am) {
				out->Append(" AM");
			}
			else {
				out->Append(" PM");
			};

			return out;
		}

		#~
		Creates a shortened string representation of the date
		@return shortened string representation of the date
		~#
		method : public : ToShortString() ~ String {
			out := String->New();

			out->Append(@month);
			out->Append('/');
			out->Append(@day);
			out->Append('/');
			out->Append(@year);
			out->Append(" ");

			is_am := true;
			if(@hours = 0) {
				out->Append(12);
			}
			else if(@hours = 12) {
				out->Append(12);
				is_am := false;
			}
			else if(@hours > 12) {
				out->Append(@hours - 12);
				is_am := false;
			}
			else {
				out->Append(@hours);
			};

			out->Append(":");
			if(@mins < 10) {
				out->Append('0');
			};
			out->Append(@mins);

			out->Append(":");
			if(@secs < 10) {
				out->Append('0');
			};
			out->Append(@secs);

			if(is_am) {
				out->Append(" AM");
			}
			else {
				out->Append(" PM");
			};

			return out;
		}
	}
	
	#~
	Provides elapsed time 
	~#	
	class Timer {
		@elapsed : Int;
		
		New() {
			Parent();
		}
		
		#~
		Starts the timer
		~#
		method : public : Start() ~ Nil {
			TIMER_START;
		}
		
		#~
		Ends the timer
		~#
		method : public : End() ~ Nil {
			TIMER_END;
		}
		
		#~
		Gets the elapsed time in seconds
		~#
		method : public : GetElapsedTime() ~ Float {
			TIMER_ELAPSED;
		}
	}
}

#~
System support for threads and runtime concurrency
~#
bundle System.Concurrency {	
	#~
	Abstracts native system thread execution 
	~#	
	class Thread {
		@id : Int;
		@name : String;
		@param : System.Base;
		
		#~
		Name of the thread
		@param name name of the thread
		~#
		New(name : String) {
			Parent();
			@name := name;
		}
		
		#~
		Called to execute a new thread 
		@param param parameter to be passed into the newly executing thread 
		~#
		method : public : Execute(param : System.Base) ~ Nil {
			@param := param;
			ASYNC_MTHD_CALL;
		}

		#~
		Sleeps the executing thread
		@param t sleep time in milliseconds
		~#
		function : Sleep(t : Int) ~ Nil {
			THREAD_SLEEP;
		}
		
		#~
		Joins the executing thread with the caller
		~#
		method : public : Join() ~ Nil {
			THREAD_JOIN;
		}
		
		#~
		Returns the thread's name
		@param thread's name
		~#
		method : public : GetName() ~ String {
			return @name;
		}
		
		#~
		Returns a unique execution ID
		@param execution ID
		~#
		method : public : GetExecuteID() ~ Int {
			return @id;
		}
		
		#~
		Prototype for the thread to be executed
		@param param parameter to be passed into the thread 
		~#
		method : virtual : public : Run(param : System.Base) ~ Nil;
	}	
	
	#~
	Thread mutex used to protect critical sections 
	~#	
	class ThreadMutex {
		@name : String;
		# hack to hold a mutex struct.  Largest struct 
		# is 64-bytes for x64 POSIX
		@m0 : Int;
		@m1 : Int;
		@m2 : Int;
		@m3 : Int;
		@m4 : Int;
		@m5 : Int;
		@m6 : Int;
		@m7 : Int;
		
		#~
		Name of the mutex
		@param name name of the mutex
		~#
		New(name : String) {
			Parent();
			@name := name;
			THREAD_MUTEX;
		}
		
		#~
		Name of the mutex
		@return name of the mutex
		~#
		method : public : GetName() ~ String {
			return @name;
		}
	}
}

#~
Provides support for matrix math
~#
bundle System.Matrix {
	#~
	Encapsulates 2D matrix operations
	~#
	class Matrix2D {
		#~
		Adds a constant to a matrix
		@param x constant to add
		@param b matrix
		@return updated matrix
		~#
		function : native : Add(x : Float, b : Float[,]) ~ Float[,] {
			b_dims := b->Size();
			b_rows := b_dims[0];
			b_cols := b_dims[1];

			c := Float->New[b_rows, b_cols];
			for(i := 0; i < b_rows; i += 1;) {
				for(j := 0; j < b_cols; j += 1;) {
					c[i,j] := x + b[i,j];
				};
			};

			return c;
		}

		#~
		Adds a constant to a matrix
		@param b matrix
		@param x constant to add
		@return updated matrix
		~#
		function : native : Add(b : Float[,], x : Float) ~ Float[,] {
			b_dims := b->Size();
			b_rows := b_dims[0];
			b_cols := b_dims[1];

			c := Float->New[b_rows, b_cols];
			for(i := 0; i < b_rows; i += 1;) {
				for(j := 0; j < b_cols; j += 1;) {
					c[i,j] := b[i,j] + x;
				};
			};

			return c;
		}
		
		#~
		Adds two matrices
		@param a matrix
		@param b matrix
		@return updated matrix
		~#
		function : native : Add(a : Float[,], b : Float[,]) ~ Float[,] {
			a_dims := a->Size();
			a_rows := a_dims[0];
			a_cols := a_dims[1];

			b_dims := b->Size();
			b_rows := b_dims[0];
			b_cols := b_dims[1];

			if( a_rows <> b_rows | a_cols <> b_cols) {
				return Nil;
			};

			c := Float->New[a_rows, b_cols];
			for(i := 0; i < a_rows; i += 1;) {
				for(j := 0; j < b_cols; j += 1;) {
					c[i,j] := a[i,j] + b[i,j];
				};
			};

			return c;
		}

		#~
		Subtracts a constant from a matrix
		@param x constant to subtract
		@param b matrix
		@return updated matrix
		~#
		function : native : Subtract(x : Float, b : Float[,]) ~ Float[,] {
			b_dims := b->Size();
			b_rows := b_dims[0];
			b_cols := b_dims[1];

			c := Float->New[b_rows, b_cols];
			for(i := 0; i < b_rows; i += 1;) {
				for(j := 0; j < b_cols; j += 1;) {
					c[i,j] := x - b[i,j];
				};
			};

			return c;
		}
		
		#~
		Adds a constant to a matrix
		@param b matrix
		@param x constant to add
		@return updated matrix
		~#
		function : native : Subtract(b : Float[,], x : Float) ~ Float[,] {
			b_dims := b->Size();
			b_rows := b_dims[0];
			b_cols := b_dims[1];

			c := Float->New[b_rows, b_cols];
			for(i := 0; i < b_rows; i += 1;) {
				for(j := 0; j < b_cols; j += 1;) {
					c[i,j] := b[i,j] - x;
				};
			};

			return c;
		}

		#~
		Subtracts two matrices
		@param a matrix
		@param b matrix
		@return updated matrix
		~#
		function : native : Subtract(a : Float[,], b : Float[,]) ~ Float[,] {
			a_dims := a->Size();
			a_rows := a_dims[0];
			a_cols := a_dims[1];

			b_dims := b->Size();
			b_rows := b_dims[0];
			b_cols := b_dims[1];

			if( a_rows <> b_rows | a_cols <> b_cols) {
				return Nil;
			};

			c := Float->New[a_rows, b_cols];
			for(i := 0; i < a_rows; i += 1;) {
				for(j := 0; j < b_cols; j += 1;) {
					c[i,j] := a[i,j] - b[i,j];
				};
			};

			return c;
		}

		#~
		Multiplies a constant by a matrix
		@param x constant to multiple
		@param b matrix
		@return updated matrix
		~#
		function : native : Multiple(x : Float, b : Float[,]) ~ Float[,] {
			b_dims := b->Size();
			b_rows := b_dims[0];
			b_cols := b_dims[1];

			c := Float->New[b_rows, b_cols];
			for(i := 0; i < b_rows; i += 1;) {
				for(j := 0; j < b_cols; j += 1;) {
					c[i,j] := x * b[i,j];
				};
			};

			return c;
		}

		#~
		Multiplies a constant by a matrix
		@param b matrix
		@param x constant to multiple
		@return updated matrix
		~#
		function : native : Multiple(b : Float[,], x : Float) ~ Float[,] {
			b_dims := b->Size();
			b_rows := b_dims[0];
			b_cols := b_dims[1];

			c := Float->New[b_rows, b_cols];
			for(i := 0; i < b_rows; i += 1;) {
				for(j := 0; j < b_cols; j += 1;) {
					c[i,j] := b[i,j] * x;
				};
			};

			return c;
		}
		
		#~
		Multiplies two matrices using the Hadamard rule
		@param a matrix
		@param b matrix
		@return updated matrix
		~#
		function : native : Multiple(a : Float[,], b : Float[,]) ~ Float[,] {
			a_dims := a->Size();
			a_rows := a_dims[0];
			a_cols := a_dims[1];

			b_dims := b->Size();
			b_rows := b_dims[0];
			b_cols := b_dims[1];

			if( a_rows <> b_rows | a_cols <> b_cols) {
				return Nil;
			};

			c := Float->New[a_rows, b_cols];
			for(i := 0; i < a_rows; i += 1;) {
				for(j := 0; j < b_cols; j += 1;) {
					c[i,j] := a[i,j] * b[i,j];
				};
			};

			return c;
		}

		#~
		Divides a constant by a matrix
		@param b matrix
		@param x constant to divide
		@return updated matrix
		~#
		function : native : Divide(b : Float[,], x : Float) ~ Float[,] {
			b_dims := b->Size();
			b_rows := b_dims[0];
			b_cols := b_dims[1];

			c := Float->New[b_rows, b_cols];
			for(i := 0; i < b_rows; i += 1;) {
				for(j := 0; j < b_cols; j += 1;) {
					c[i,j] := b[i,j] / x;
				};
			};

			return c;
		}

		#~
		Divides a constant by a matrix
		@param x constant to divide
		@param b matrix
		@return updated matrix
		~#
		function : native : Divide(x : Float, b : Float[,]) ~ Float[,] {
			b_dims := b->Size();
			b_rows := b_dims[0];
			b_cols := b_dims[1];

			c := Float->New[b_rows, b_cols];
			for(i := 0; i < b_rows; i += 1;) {
				for(j := 0; j < b_cols; j += 1;) {
					c[i,j] := b[i,j] / x;
				};
			};

			return c;
		}

		#~
		Divides two matrices
		@param a matrix
		@param b matrix
		@return updated matrix
		~#
		function : native : Divide(a : Float[,], b : Float[,]) ~ Float[,] {
			a_dims := a->Size();
			a_rows := a_dims[0];
			a_cols := a_dims[1];

			b_dims := b->Size();
			b_rows := b_dims[0];
			b_cols := b_dims[1];

			if( a_rows <> b_rows | a_cols <> b_cols) {
				return Nil;
			};

			c := Float->New[a_rows, b_cols];
			for(i := 0; i < a_rows; i += 1;) {
				for(j := 0; j < b_cols; j += 1;) {
					c[i,j] := a[i,j] / b[i,j];
				};
			};

			return c;
		}

		#~
		Transpose a matrix swapping rows and columns.
		@param a matrix
		@return transposed matrix
		~#
		function : native : Transpose(a : Float[,]) ~ Float[,] {
			dim := a->Size();
			rows := dim[0];
			cols := dim[1];

			b := Float->New[cols, rows];
			for(r := 0; r < rows; r += 1;) {
				for(c := 0; c < cols; c += 1;) {
					b[c,r] := a[r,c];
				};
			};

			return b;
		}

		#~
		Calculates the dot product.
		@param a matrix
		@param b matrix
		@return updated matrix
		~#
		function : native : Dot(a : Float[,], b : Float[,]) ~ Float[,] {
			a_dims := a->Size();
			a_rows := a_dims[0];
			a_cols := a_dims[1];

			b_dims := b->Size();
			b_rows := b_dims[0];
			b_cols := b_dims[1];

			if(a_cols <> b_rows & a_rows <> b_cols) {
				return Nil;
			};

			c := Float->New[a_rows, b_cols];
			for(a_col := 0; a_col < a_rows; a_col += 1;) {
				for(b_col := 0; b_col < b_cols; b_col += 1;) {
					cx := 0.0;
					for(x_col := 0; x_col < b_rows; x_col += 1;) {
						cx += a[a_col, x_col] * b[x_col, b_col];
					};
					c[a_col, b_col] := cx;
				};
			};

			return c;
		}

		#~
		Sigmoid 'S' function
		@param x input value
		@return Sigmoid value
		~#
		function : native : Sigmoid(x : Float) ~ Float {
			return 1.0 / (1.0 + Float->Power(Float->E(), -1.0 * x));
		}

		#~
		Applies the Sigmoid function to all elements
		@param b matrix
		@return updated matrix
		~#
		function : native : Sigmoid(b : Float[,]) ~ Float[,] {
			b_dims := b->Size();
			b_rows := b_dims[0];
			b_cols := b_dims[1];

			c := Float->New[b_rows, b_cols];
			for(i := 0; i < b_rows; i += 1;) {
				for(j := 0; j < b_cols; j += 1;) {
					c[i,j] := Sigmoid(b[i,j]);
				};
			};

			return c;
		}
		
		#~
		Calculates the Dot Product applying while applying the Sigmoid function to all elements
		@param a matrix
		@param b matrix
		@return updated matrix
		~#
		function : native : DotSigmoid(a : Float[,], b : Float[,]) ~ Float[,] {
			a_dims := a->Size();
			a_rows := a_dims[0];
			a_cols := a_dims[1];

			b_dims := b->Size();
			b_rows := b_dims[0];
			b_cols := b_dims[1];
			
			if(a_cols <> b_rows & a_rows <> b_cols) {
				return Nil;
			};

			c := Float->New[a_rows, b_cols];
			for(a_col := 0; a_col < a_rows; a_col += 1;) {
				for(b_col := 0; b_col < b_cols; b_col += 1;) {
					cx := 0.0;
					for(x_col := 0; x_col < b_rows; x_col += 1;) {
						cx += a[a_col, x_col] * b[x_col, b_col];
					};
					c[a_col, b_col] := Sigmoid(cx);
				};
			};

			return c;
		}

		#~
		Generates a random 2D array of values from 0.0 to 1.0
		@param rows rows
		@param cols columns
		@return updated matrix
		~#
		function : Random(rows : Int, cols : Int) ~ Float[,] {
			m := Float->New[rows, cols];

			for(i := 0; i < rows; i += 1;) {
				for(j := 0; j < cols; j += 1;) {
					m[i,j] := Float->Random();
				};
			};
			
			return m;
		}
		
		#~
		Generates a random normal distribution of values
		@param mean center of values
		@param variance variance in values
		@param rows rows
		@param cols columns
		@return updated matrix
		~#
		function : RandomNormal(mean : Float, variance : Float, rows : Int, cols : Int) ~ Float[,] {
			m := Float->New[rows, cols];

			for(i := 0; i < rows; i += 1;) {
				for(j := 0; j < cols; j += 1;) {
					m[i,j] := RandomNormal(mean, variance);
				};
			};

			return m;
		}

		#~
		Generates a random normal value
		@param mean center of values
		@param variance variance in values
		@return updated matrix
		~#
		function : RandomNormal(mean : Float, variance : Float) ~ Float {
			return  (-2.0 * variance * Float->Random()->Log())->SquareRoot() * (2.0 * Float->Pi() * Float->Random())->Cos() + mean;
		}

		#~
		Splits a matrix
		@param b matrix
		@param offset offset index
		@param count number of rows to split
		@param is_row true for row split, false for column
		@return copied matrix
		~#
		function : Split(b : Float[,], offset : Int, count : Int, is_row : Bool) ~ Float[,] {
			b_dims := b->Size();
			b_rows := b_dims[0];
			b_cols := b_dims[1];
			
			c : Float[,];
			if(is_row) {
				if(count + offset <= 0 | count + offset > b_rows) {
					return Nil;
				};

				c := Float->New[count, b_cols];
				count := count + offset;
				for(row := offset; row < count; row += 1;) {
					for(col := 0; col < b_cols; col += 1;) {
						c[row - offset, col] := b[row, col];
					};
				};
			}
			else {
				if(count + offset <= 0 | count + offset > b_cols) {
					return Nil;
				};

				c := Float->New[b_rows, count];
				count := count + offset;
				for(row := 0; row < b_rows; row += 1;) {
					for(col := offset; col < count; col += 1;) {
						c[row, col - offset] := b[row, col];
					};
				};
			};

			return c;
		}
		
		#~
		Concatenates two matrix
		@param a left matrix
		@param b right matrix
		@param is_row true concatenate by rows, false for columns
		@return concatenated matrix
		~#
		function : Concatenate(a : Float[,], b : Float[,], is_row : Bool) ~ Float[,] {
			a_dims := a->Size();
			a_rows := a_dims[0];
			a_cols := a_dims[1];

			b_dims := b->Size();
			b_rows := b_dims[0];
			b_cols := b_dims[1];

			c : Float[,];
			if(is_row) {
				if(a_cols <> b_cols) {
					return Nil;
				};

				c_rows := a_rows + b_rows;
				c := Float->New[c_rows, a_cols];

				for(row := 0; row < a_rows; row += 1;) {
					for(col := 0; col < a_cols; col += 1;) {
						c[row, col] := a[row, col];
					};
				};

				for(row := 0; row < b_rows; row += 1;) {
					for(col := 0; col < b_cols; col += 1;) {
						c[row + a_rows, col] := b[row, col];
					};
				};
			}
			else {
				if(a_rows <> b_rows) {
					return Nil;
				};

				c_cols := a_cols + b_cols;
				c := Float->New[a_rows, c_cols];

				for(row := 0; row < a_rows; row += 1;) {
					for(col := 0; col < a_cols; col += 1;) {
						c[row, col] := a[row, col];
					};
				};

				for(row := 0; row < b_rows; row += 1;) {
					for(col := 0; col < b_cols; col += 1;) {
						c[row, col + a_cols] := b[row, col];
					};
				};
			};

			return c;
		}
	}
}

#~
Provides I/O functions
~#
bundle System.IO {
	#~
	An abstract input stream
	~#
	interface InputStream {
		#~
		Reads a byte
		@return byte read
		~#
		method : virtual : public : ReadByte() ~ Byte;
		
		#~
		Reads bytes into a byte buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : virtual : public : ReadBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int;
		
		#~
		Reads bytes into a character buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : virtual : public : ReadBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int;
		
		#~
		Reads a string until a newline or character return is detected 
		@return character string
		~#
		method : virtual : public : ReadString() ~ System.String;
		
		#~
		Closes the stream
		~#
		method : virtual : public : Close() ~ Nil;
	}
	
	#~
	An abstract output stream
	~#
	interface OutputStream {
		#~
		Writes a byte
		@param b byte to write
		@return true if byte was written, false otherwise
		~#
		method : virtual : public : WriteByte(b : Int) ~ Bool;
		
		#~
		Writes bytes from a buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of values written
		~#
		method : virtual : public : WriteBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int;
		
		#~
		Writes characters from a buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of values written
		~#
		method : virtual : public : WriteBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int;
		
		#~
		Writes a character string
		@param str string to be written
		~#
		method : virtual : public : WriteString(str : System.String) ~ Nil;
		
		#~
		Closes the stream
		~#
		method : virtual : public : Close() ~ Nil;
	}
	
 	#~
	Provides I/O console access
	~#
	class Console {
		#~
		Reads a string from STDIN
		@return string read
		~#
		function : ReadString() ~ System.String {
			console := IO.ConsoleIO->Instance();
			return console->ReadString();
		}

		#~
		Write a byte buffer to STDOUT
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return true if successful, false otherwise
		~#
		function : public : WriteBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Bool {
			STD_OUT_BYTE_ARY_LEN;	
		}

		#~
		Write a character buffer to STDOUT
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return true if successful, false otherwise
		~#
		function : public : WriteBuffer(offset : Int, num : Int, buffer : Char[]) ~ Bool {
			STD_OUT_CHAR_ARY_LEN;
		}

		#~
		Write a byte buffer to STDERR
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return true if successful, false otherwise
		~#
		function : public : WriteErrorBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Bool {
			STD_ERR_BYTE_ARY;	
		}

		#~
		Write a character buffer to STDERR
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return true if successful, false otherwise
		~#
		function : public : WriteErrorBuffer(offset : Int, num : Int, buffer : Char[]) ~ Bool {
			STD_ERR_BYTE_ARY;
		}

		function : ErrorFlush() ~ Nil {
			STD_ERR_FLUSH;
		}
		
		function : Flush() ~ Nil {
			STD_FLUSH;
		}

		#~

		Writes a value
		@param b value
		@return I/O console instance
		~#
		function : Print(b : Bool) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(b);
		}
		
		#~
		Writes a value
		@param b value
		@return I/O console instance
		~#
		function : PrintLine(b : Bool) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(b);
		}
	
		#~
		Writes a value
		@param b value
		@return I/O console instance
		~#
		function : Print(b : Byte) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(b);
		}
	
		#~
		Writes a value
		@param b value
		@return I/O console instance
		~#
		function : PrintLine(b : Byte) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(b);
		}
		
		#~
		Writes a value
		@param c value
		@return I/O console instance
		~#
		function : Print(c : Char) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(c);
		}
	
		#~
		Writes a value
		@param c value
		@return I/O console instance
		~#
		function : PrintLine(c : Char) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(c);
		}
	
		#~
		Writes a value
		@param i value
		@return I/O console instance
		~#
		function : Print(i : Int) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(i);
		}
	
		#~
		Writes a value
		@param i value
		@return I/O console instance
		~#
		function : PrintLine(i : Int) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(i);
		}
		
		#~
		Writes a value
		@param f value
		@return I/O console instance
		~#
		function : Print(f : Float) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(f);
		}
	
		#~
		Writes a value
		@param f value
		@return I/O console instance
		~#
		function : PrintLine(f : Float) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(f);
		}
	
		#~
		Writes a value
		@param cc value
		@return I/O console instance
		~#
		function : Print(cc : Char[]) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(cc);
		}
	
		#~
		Writes a value
		@param cc value
		@return I/O console instance
		~#
		function : PrintLine(cc : Char[]) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(cc);
		}
		
		#~
		Writes a value
		@param s value
		@return I/O console instance
		~#
		function : Print(s : System.String) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Print(s);
		}
	
		#~
		Writes a value
		@param s value
		@return I/O console instance
		~#
		function : PrintLine(s : System.String) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine(s);
		}
	
		#~
		Prints a character return
		@return I/O console instance
		~#
		function : PrintLine() ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->PrintLine();
		}

		#~
		Writes an error value
		@param b value
		@return I/O console instance
		~#
		function : Error(b : Bool) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Error(b);
		}
		
		#~
		Writes an error value
		@param b value
		@return I/O console instance
		~#
		function : ErrorLine(b : Bool) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->ErrorLine(b);
		}
	
		#~
		Writes an error value
		@param b value
		@return I/O console instance
		~#
		function : Error(b : Byte) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Error(b);
		}
	
		#~
		Writes an error value
		@param b value
		@return I/O console instance
		~#
		function : ErrorLine(b : Byte) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->ErrorLine(b);
		}
		
		#~
		Writes an error value
		@param c value
		@return I/O console instance
		~#
		function : Error(c : Char) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Error(c);
		}
	
		#~
		Writes an error value
		@param c value
		@return I/O console instance
		~#
		function : ErrorLine(c : Char) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->ErrorLine(c);
		}
	
		#~
		Writes an error value
		@param i value
		@return I/O console instance
		~#
		function : Error(i : Int) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Error(i);
		}
	
		#~
		Writes an error value
		@param i value
		@return I/O console instance
		~#
		function : ErrorLine(i : Int) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->ErrorLine(i);
		}
		
		#~
		Writes an error value
		@param f value
		@return I/O console instance
		~#
		function : Error(f : Float) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Error(f);
		}
	
		#~
		Writes an error value
		@param f value
		@return I/O console instance
		~#
		function : ErrorLine(f : Float) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->ErrorLine(f);
		}
	
		#~
		Writes an error value
		@param cc value
		@return I/O console instance
		~#
		function : Error(cc : Char[]) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Error(cc);
		}
	
		#~
		Writes an error value
		@param cc value
		@return I/O console instance
		~#
		function : ErrorLine(cc : Char[]) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->ErrorLine(cc);
		}
		
		#~
		Writes an error value
		@param s value
		@return I/O console instance
		~#
		function : Error(s : System.String) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->Error(s);
		}
	
		#~
		Writes an error value
		@param s value
		@return I/O console instance
		~#
		function : ErrorLine(s : System.String) ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->ErrorLine(s);
		}
	
		#~
		Writes an error character return
		@return I/O console instance
		~#
		function : ErrorLine() ~ ConsoleIO {
			return IO.ConsoleIO->Instance()->ErrorLine();
		}
	}
 	
 	class ConsoleIO {
		@console : static : ConsoleIO;

		New : private () {
			Parent();
		}

		function : Instance() ~ ConsoleIO {
			if(@console <> Nil) {
				@console := ConsoleIO->New();
			};

			return @console;
		}

		method : public : ReadString() ~ System.String {
			buffer : Char[] := Char->New[1024];
			ReadString(buffer);
			return System.String->New(buffer);
		}
		
		method : public : Print(b : Bool) ~ ConsoleIO {
			b->Print();
			return @console;
		}
		
		method : public : PrintLine(b : Bool) ~ ConsoleIO {
			b->PrintLine();
			return @console;
		}

		method : ReadString(buffer : Char[]) ~ Nil {
			STD_IN_STRING;
		}
		
		method : public : Print(b : Byte) ~ ConsoleIO {
			b->Print();
			return @console;
		}

		method : public : PrintLine(b : Byte) ~ ConsoleIO {
			b->PrintLine();
			return @console;
		}
		
		method : public : Print(c : Char) ~ ConsoleIO {
			c->Print();
			return @console;
		}

		method : public : PrintLine(c : Char) ~ ConsoleIO {
			c->PrintLine();
			return @console;
		}

		method : public : Print(i : Int) ~ ConsoleIO {
			i->Print();
			return @console;
		}

		method : public : PrintLine(i : Int) ~ ConsoleIO {
			i->PrintLine();
			return @console;
		}
		
		method : public : Print(f : Float) ~ ConsoleIO {
			f->Print();
			return @console;
		}

		method : public : PrintLine(f : Float) ~ ConsoleIO {
			f->PrintLine();
			return @console;
		}

		method : public : Print(cc : Char[]) ~ ConsoleIO {
			cc->Print();
			return @console;
		}

		method : public : PrintLine(cc : Char[]) ~ ConsoleIO {
			cc->PrintLine();
			return @console;
		}
		
		method : public : Print(s : System.String) ~ ConsoleIO {
			s->Print();
			return @console;
		}

		method : public : PrintLine(s : System.String) ~ ConsoleIO {
			s->PrintLine();
			return @console;
		}

		method : public : PrintLine() ~ ConsoleIO {
			"\r\n"->Print();
			return @console;
		}
		
		method : public : Error(b : Bool) ~ ConsoleIO {
			b->Error();
			return @console;
		}
		
		method : public : ErrorLine(b : Bool) ~ ConsoleIO {
			b->ErrorLine();
			return @console;
		}

		method : public : Error(b : Byte) ~ ConsoleIO {
			b->Error();
			return @console;
		}

		method : public : ErrorLine(b : Byte) ~ ConsoleIO {
			b->ErrorLine();
			return @console;
		}
		
		method : public : Error(c : Char) ~ ConsoleIO {
			c->Error();
			return @console;
		}

		method : public : ErrorLine(c : Char) ~ ConsoleIO {
			c->ErrorLine();
			return @console;
		}

		method : public : Error(i : Int) ~ ConsoleIO {
			i->Error();
			return @console;
		}

		method : public : ErrorLine(i : Int) ~ ConsoleIO {
			i->ErrorLine();
			return @console;
		}
		
		method : public : Error(f : Float) ~ ConsoleIO {
			f->Error();
			return @console;
		}

		method : public : ErrorLine(f : Float) ~ ConsoleIO {
			f->ErrorLine();
			return @console;
		}

		method : public : Error(cc : Char[]) ~ ConsoleIO {
			cc->Error();
			return @console;
		}

		method : public : ErrorLine(cc : Char[]) ~ ConsoleIO {
			cc->ErrorLine();
			return @console;
		}
		
		method : public : Error(s : System.String) ~ ConsoleIO {
			s->Error();
			return @console;
		}

		method : public : ErrorLine(s : System.String) ~ ConsoleIO {
			s->ErrorLine();
			return @console;
		}

		method : public : ErrorLine() ~ ConsoleIO {
			'\n'->ErrorLine();
			return @console;
		}
	}
	
	#~
	Used to serialize objects
	~#
	class Serializer  {
		@buffer : Byte[];
		@pos : Int;

		
		New() {
			Parent();
			@buffer := Byte->New[16];
			@pos := 0;
		}

		#~
		Serializes a value
		@param b value to serialize
		~#
		method : public : Write(b : Bool) ~ Nil {
			SERL_INT;
		}

		#~
		Serializes a value
		@param c value to serialize
		~#
		method : public : Write(c : Char) ~ Nil {
			SERL_CHAR;
		}
		
		#~
		Serializes a value
		@param i value to serialize
		~#
		method : public : Write(i : Int) ~ Nil {
			SERL_INT;
		}
		
		#~
		Serializes a value
		@param f value to serialize
		~#
		method : public : Write(f : Float) ~ Nil {
			SERL_FLOAT;
		}
		
		#~
		Serializes a base object
		@param o value to serialize
		~#
		method : public : Write(o : Base) ~ Nil {
			SERL_OBJ_INST;
		}

		#~
		Serializes a base object
		@param b value to serialize
		~#
		method : public : Write(b : Bool[]) ~ Nil {
			SERL_INT_ARY;
		}

		#~
		Serializes base objects
		@param o value to serialize
		~#
		method : public : Write(o : Base[]) ~ Nil {
			SERL_OBJ_ARY;
		}

		#~
		Serializes a value
		@param b value to serialize
		~#
		method : public : Write(b : Byte[]) ~ Nil {
			SERL_BYTE_ARY;
		}

		#~
		Serializes an array of values
		@param c value to serialize
		~#
		method : public : Write(c : Char[]) ~ Nil {
			SERL_CHAR_ARY;
		}

		#~
		Serializes an array of values
		@param i value to serialize
		~#
		method : public : Write(i : Int[]) ~ Nil {
			SERL_INT_ARY;
		}
		
		#~
		Serializes an array of values
		@param f value to serialize
		~#
		method : public : Write(f : Float[]) ~ Nil {
			SERL_FLOAT_ARY;
		}
		
		#~
		Create a byte stream of the objects that 
		have been serialized
		@return byte stream of the objects that have been serialized
		~#
		method : public : Serialize() ~ Byte[] {
			return Byte->Compress(@buffer);
		}
	}
	
	#~
	Used to deserialize objects
	~#
	class Deserializer  {
		@buffer : Byte[];
		@pos : Int;
		
		#~
		Default constructor
		@param buffer input byte buffer to read from
		~#
		New(buffer : Byte[]) {
			Parent();
			@buffer := Byte->Uncompress(buffer);
			@pos := 0;
		}

		#~
		Reads a value
		@return value read
		~#
		method : public : ReadBool() ~ Bool {
			DESERL_INT;
		}

		#~
		Reads a value
		@return value read
		~#
		method : public : ReadChar() ~ Char {
			DESERL_CHAR;
		}

		#~
		Reads a value
		@return value read
		~#		
		method : public : ReadInt() ~ Int {
			DESERL_INT;
		}

		#~
		Reads a value
		@return value read
		~#		
		method : public : ReadFloat() ~ Float {
			DESERL_FLOAT;
		}
		
		#~
		Reads an object
		@return value read
		~#
		method : public : ReadObject() ~ Base {
			DESERL_OBJ_INST;
		}

		#~
		Reads an object array
		@return value read
		~#
		method : public : ReadObjectArray() ~ Base[] {
			DESERL_OBJ_ARY;
		}

		#~
		Reads an array of values
		@return array of values
		~#
		method : public : ReadBoolArray() ~ Bool[] {
			DESERL_INT_ARY;
		}

		#~
		Reads an array of values
		@return array of values
		~#
		method : public : ReadByteArray() ~ Byte[] {
			DESERL_BYTE_ARY;
		}

		#~
		Reads an array of values
		@return array of values
		~#
		method : public : ReadCharArray() ~ Char[] {
			DESERL_CHAR_ARY;
		}

		#~
		Reads an array of values
		@return array of values
		~#
		method : public : ReadIntArray() ~ Int[] {
			DESERL_INT_ARY;
		}

		#~
		Reads an array of values
		@return array of values
		~#		
		method : public : ReadFloatArray() ~ Float[] {
			DESERL_FLOAT_ARY;
		}
	}
}

#~
Supports file I/O operations
~#
bundle System.IO.File {	
	#~
	Provides file operations
	~#
	class File {
		@handle : Int;
		@name : System.String;
		
		#~
		Default constructor
		@param name file name
		~#
		New(name : System.String) {
			Parent();
			@name := name;
		}
		
		#~
		Gets the file name
		@return file name
		~#
		method : public : GetName() ~ String {
			return @name;
		}

		#~
		Checks of the file is open
		@return true if the file was opened, false otherwise
		~#
		method : public : IsOpen() ~ Bool {
			FILE_IS_OPEN;
		}

		#~
		Seeks to a point in the file
		@param p seek offset
		@return true if operation was successful, false otherwise
		~#
		method : public : Seek(p : Int) ~ Bool {
			FILE_SEEK;
		}
		
		#~
		Rewinds the seek pointer
		~#
		method : public : Rewind() ~ Nil {
			FILE_REWIND;
		}

		#~
		Check if seek pointer is at the end-of-file
		@return true if at the end-of-file, false otherwise
		~#
		method : public : IsEOF() ~ Bool {
			FILE_EOF;
		}

		#~
		Gets the full path name for file
		@param n file name
		@return full path name, Nil otherwise
		~#
		function : GetFullName(n : System.String) ~ System.String {
			FILE_FULL_PATH;
		}

    #~
		Gets the full path name for file
		@return full path name, Nil otherwise
		~#
		method : public : GetFullName() ~ System.String {
			return GetFullName(@name);;
		}

		#~
		Gets a temporary file name
		@return temporary file name
		~#
		function : GetTempName() ~ System.String {
			FILE_TEMP_NAME;
		}

		#~
		Returns the size of the file
		@param n file name
		@return size of the file
		~#
		function : Size(n : System.String) ~ Int {
			FILE_SIZE;
		}		

        #~
		Returns the size of the file
		@return size of the file
		~#
		method : public : Size() ~ Int {
			return Size(@name);
		}
		
		#~
		Returns the time in which the file was created
		@param n file name
		@return create date
		~#
		function : CreateTime(n : System.String) ~ Date {
			return CreateTime(n, false);
		}

        #~
		Returns the time in which the file was created
		@return create date
		~#
		method : public : CreateTime() ~ Date {
			return CreateTime(@name, false);
		}

		#~
		Returns the time in which the file was created
		@param n file name
		@param gmt true if GMT
		@return create date
		~#
		function : CreateTime(n : System.String, gmt : Bool) ~ Date {
			day : Int; 
			month : Int; 
			year : Int; 
			hours : Int; 
			mins : Int; 
			secs : Int; 

			FILE_CREATE_TIME;

			return Date->New(day, month, year, hours, mins, secs, gmt);
		}

        #~
		Returns the time in which the file was created
		@param gmt true if GMT
		@return create date
		~#
		method : public : CreateTime(gmt : Bool) ~ Date {	
		    return CreateTime(@name, gmt);
        }
        
		#~
		Returns the time in which the file was modified 
		@param n file name
		@return modified date
		~#
		function : ModifiedTime(n : System.String) ~ Date {
			return ModifiedTime(n, false);
		}

		#~
		Returns the time in which the file was modified 
		@param n file name
		@param gmt true if GMT
		@return modified date
		~#
		function : ModifiedTime(n : System.String, gmt : Bool) ~ Date {
			day : Int; 
			month : Int; 
			year : Int; 
			hours : Int; 
			mins : Int; 
			secs : Int; 

			FILE_MODIFIED_TIME;

			return Date->New(day, month, year, hours, mins, secs, gmt);
		}		

		#~
		Returns the time in which the file was accessed 
		@param n file name
		@return accessed date
		~#
		function : AccessedTime(n : System.String) ~ Date {
			return AccessedTime(n, false);
		}

        #~
		Returns the time in which the file was accessed 
		@return accessed date
		~#
		method : public : AccessedTime() ~ Date {
            return AccessedTime(@name, false);
        }
        
		#~
		Returns the time in which the file was accessed 
		@param n file name
		@param gmt true if GMT
		@return accessed date
		~#
		function : AccessedTime(n : System.String, gmt : Bool) ~ Date {
			day : Int;
			month : Int;
			year : Int;
			hours : Int;
			mins : Int;
			secs : Int;
			
			FILE_ACCESSED_TIME;
			
			return Date->New(day, month, year, hours, mins, secs, gmt);
		}

        #~
		Returns the time in which the file was accessed 
		@param gmt true if GMT
		@return accessed date
		~#
		method : public : AccessedTime(gmt : Bool) ~ Date {
		    return AccessedTime(@name, gmt);
        }
        
		#~
		Deletes a file
		@param n file name
		@return true if file was deleted
		~#
		function : Delete(n : System.String) ~ Bool {
			FILE_DELETE;
		}

        #~
		Deletes a file
		@return true if file was deleted
		~#
		method : public : Delete() ~ Bool {
			if(Delete(@name)) {
				@handle := 0;
				return true;
			};

			return false;
		}
		
		#~
		Gets the file owner name
		@param n file name
		@return file owner name
		~#
		function : Owner(n : System.String) ~ System.String {
			FILE_ACCOUNT_OWNER;
		}

        #~
		Gets the file owner name
		@return file owner name
		~#
		method : public : Owner() ~ System.String {
			return Owner(@name);
		}

		#~
		Gets the file group name
		@param n file name
		@return file group name
		~#
		function : Group(n : System.String) ~ System.String {
			FILE_GROUP_OWNER;
		}

        #~
		Gets the file group name
		@return file group name
		~#
		method : public : Group() ~ System.String {
			return Group(@name);
		}

		#~
		Check to see if a file can be read-only
		@param n file name
		@return true if file can be read-only
		~#
		function : IsReadWrite(n : System.String) ~ Bool {
			FILE_CAN_READ_WRITE;
		}

        #~
		Check to see if a file can be read-only
		@return true if file can be read-only
		~#
		method : public : IsReadWrite() ~ Bool {
			return IsReadWrite(@name);
		}

		#~
		Check to see if a file can be read
		@param n file name
		@return true if file can be read
		~#
		function : IsReadOnly(n : System.String) ~ Bool {
			FILE_CAN_READ_ONLY;
		}

        #~
		Check to see if a file can be read
		@return true if file can be read
		~#
		method : public : IsReadOnly() ~ Bool {
			return IsReadOnly(@name);
		}
		
		#~
		Check to see if a file can be written
		@param n file name
		@return true if file can be written
		~#
		function : IsWriteOnly(n : System.String) ~ Bool {
			FILE_CAN_WRITE_ONLY;
		}
        
        #~
		Check to see if a file can be written
		@return true if file can be written
		~#
		method : public : IsWriteOnly() ~ Bool {
			return IsWriteOnly(@name);
		}
		
		#~
		Check to see if a file exists
		@param n file name
		@return true if file exists
		~#
		function : Exists(n : System.String) ~ Bool {
			FILE_EXISTS;
		}

        #~
		Check to see if a file exists
		@return true if file exists
		~#
		method : public : Exists() ~ Bool {
			return Exists(@name);
		}
		
		#~
		Renames a file
		@param o original file name
		@param n new file name
		@return true if file was renamed
		~#
		function : Rename(o : System.String, n : System.String) ~ Bool {
			FILE_RENAME;
		}
	}

	#~
	Supports file read operations
	~#
	class FileReader from File implements InputStream {
		#~
		Default constructor.
		@param name file name
		~#
		New(name : System.String) {
			Parent(name);
			FILE_OPEN_READ;
		}	

		#~
		Closes the file
		~#
		method : public : Close() ~ Nil {
			FILE_CLOSE;
		}

		#~
		Reads a byte
		@return byte read
		~#
		method : public : ReadByte() ~ Byte {
			FILE_IN_BYTE;
		}

		#~
		Reads bytes into a byte buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			FILE_IN_CHAR_ARY;
		}

		#~
		Reads bytes into a character buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			FILE_IN_BYTE_ARY;
		}

		#~
		Reads a string until a newline or character return is detected 
		@return character string
		~#
		method : public : ReadString() ~ System.String {
			if(IsEOF()) {
				return Nil;
			};

			buffer : Char[] := Char->New[1024];
			ReadString(buffer);
			return System.String->New(buffer);
		}

		method : ReadString(buffer : Char[]) ~ Nil {
			FILE_IN_STRING;
		}
		
		#~
		Reads a file's contents into a string
		@param name file name
		@return character string
		~#
		function : ReadFile(name : String) ~ String {
			len := File->Size(name);
			if(len > 0) {
				buffer := Char->New[len + 1];
				in := FileReader->New(name);
				if(in->IsOpen()) {
					in->ReadBuffer(0, len, buffer);
					in->Close();
					
					return String->New(buffer);
				};
			};
	
			return Nil;
		}
		
		#~
		Reads a file's contents into byte array
		@param name file name
		@return byte array
		~#
		function : ReadBinaryFile(name : String) ~ Byte[] {
			len := File->Size(name);
			buffer := Byte->New[len];
			in := FileReader->New(name);
			if(in->IsOpen()) {
				in->ReadBuffer(0, len, buffer);
				in->Close();
				
				return buffer;
			};
			
			return Nil;
		}
	}
	
	#~
	Supports file write operations
	~#
	class FileWriter from File implements OutputStream {
		#~
		Opens a new file.
		@param name file name
		~#
		New(name : System.String) {
			Parent(name);
			FILE_OPEN_WRITE;
		}	
		
		#~
		Opens a new file or appends to an existing one.
		@param name file name
		@param append if true, opens a file for appending otherwise creates a new file
		~#
		New(name : System.String, append : Bool) {
			Parent(name);
			if(append) {
				FILE_OPEN_APPEND;
			}
			else {
				FILE_OPEN_WRITE;
			};
		}

		#~
		Creates a temporary file
		~#
		function : Temp() ~ FileWriter {
			return System.IO.File.FileWriter->New(GetTempName());
		}

		#~
		Write a file's contents into a string
		@param name file name
		@param content file content
		@return true if successful, false otherwise
		~#
		function : WriteFile(name : String, content : String) ~ Bool {
			writer : FileWriter := FileWriter->New(name);
			if(writer->IsOpen()) {
				writer->WriteString(content);
				return true;
			};

			return false;
		}
		
		#~
		Closes a file
		~#
		#~
		Closes a file
		~#
		method : public : Close() ~ Nil {
			FILE_CLOSE;
		}

		#~
		Flushes the file buffer
		~#
		method : public : Flush() ~ Nil {
			FILE_FLUSH;
		}

		#~
		Writes a byte
		@param b byte to write
		@return true if byte was written, false otherwise
		~#
		method : public : WriteByte(b : Int) ~ Bool {
			FILE_OUT_BYTE;
		}

		#~
		Writes bytes from a buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			FILE_OUT_BYTE_ARY;
		}
		
		#~
		Writes characters from a buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			FILE_OUT_CHAR_ARY;
		}

		#~
		Writes bytes from a buffer
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(buffer : Byte[]) ~ Int {
			return WriteBuffer(0, buffer->Size(), buffer);
		}
		
		#~
		Writes characters from a buffer
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(buffer : Char[]) ~ Int {
			return WriteBuffer(0, buffer->Size(), buffer);
		}
		
		#~
		Writes a character string
		@param str string to be written
		~#
		method : public : WriteString(str : System.String) ~ Nil {
			WriteString(str->ToCharArray());
		}

		method : WriteString(buffer : Char[]) ~ Nil {
			FILE_OUT_STRING;
		}
	}
	
	#~
	Logs messages to temporary files
	~#
	class Logger {
		@instance : static : Logger;
		
		@directory : String;

		@info_mutex : ThreadMutex;
		@info_dir : String;

		@warn_mutex : ThreadMutex;
		@warn_dir : String;

		@err_mutex : ThreadMutex;
		@err_dir : String;
		
		New : private () {
			Parent();		
			@directory := Runtime->GetTempDir();

			@info_dir := "";
			@info_dir->Append(@directory);
			@info_dir->Append("/info-objk.txt");
			@info_mutex := ThreadMutex->New("info-log");

			@warn_dir := "";
			@warn_dir->Append(Runtime->GetTempDir());
			@warn_dir->Append("/warn-objk.txt");
			@warn_mutex := ThreadMutex->New("warn-log");

			@err_dir := "";
			@err_dir->Append(Runtime->GetTempDir());
			@err_dir->Append("/err-objk.txt");
			@warn_mutex := ThreadMutex->New("warn-log");
			@err_mutex := ThreadMutex->New("err-log");
		}

		#~
		Gets an instance of the logger
		@return logger instance
		~#
		function : Instance() ~ Logger {
			if(@instance = Nil) {
				@instance := Logger->New();
			};

			return @instance;
		}

		#~
		Logs an informational message
		@param message message to log
		@return true if message is logged, false otherwise
		~#
		method : public : Info(message : String) ~ Bool {
			critical(@info_mutex) {
				out := FileWriter->New(@info_dir, true);
				if(out <> Nil) {
					header := "[";
					header->Append(Date->New()->ToShortString());
					header->Append("]: ");
					header->Append(message);
					out->WriteString(header);
				}
				else {
					return false;
				};
				out->Close();
			};			
			
			return true;
		}

		#~
		Logs a warning message
		@param message message to log
		@return true if message is logged, false otherwise
		~#
		method : public : Warn(message : String) ~ Bool {
			critical(@warn_mutex) {
				out := FileWriter->New(@warn_dir, true);
				if(out <> Nil) {
					header := "[";
					header->Append(Date->New()->ToShortString());
					header->Append("]: ");
					header->Append(message);
					out->WriteString(header);
				}
				else {
					return false;
				};
				out->Close();
			};			
			
			return true;
		}

		#~
		Logs an error message
		@param message message to log
		@return true if message is logged, false otherwise
		~#
		method : public : Error(message : String) ~ Bool {
			critical(@err_mutex) {
				out := FileWriter->New(@err_dir, true);
				if(out <> Nil) {
					header := "[";
					header->Append(Date->New()->ToShortString());
					header->Append("]: ");
					header->Append(message);
					out->WriteString(header);
				}
				else {
					return false;
				};
				out->Close();
			};			
			
			return true;
		}

		#~
		Clears the info log file
		@return true if message is logged, false otherwise
		~#
		method : public : ClearInfo() ~ Nil {
			critical(@info_mutex) {
				File->Delete(@info_dir);
			};
		}

		#~
		Clears the warning log file
		@return true if message is logged, false otherwise
		~#
		method : public : ClearWarn() ~ Nil {
			critical(@warn_mutex) {
				File->Delete(@warn_dir);
			};
		}

		#~
		Clears the error log file
		@return true if message is logged, false otherwise
		~#
		method : public : ClearError() ~ Nil {
			critical(@err_mutex) {
				File->Delete(@err_dir);
			};
		}

		#~
		Gets the logging directory
		@return logging directory
		~#
		method : public : GetDirectory() ~ String {
			return @directory;
		}
	}

	#~
	Provide file directory operations
	~#
	class Directory {
		#~
		Creates a directory
		@param n directory name
		@return true if directory was created 
		~#
		function : Create(n : System.String) ~ Bool {
			DIR_CREATE;
		}
		
		#~
		Creates a directory path
		@param n directory path name
		@return true if directory path was created 
		~#
		function : CreatePath(n : String) ~ Bool {	
			sub_dirs := n->Split("/");
			if(sub_dirs->Size() = 0) {
				sub_dirs := n->Split("\\");
			};		
			
			if(sub_dirs->Size() > 0) {
				is_okay := true;
				
				i := 0;
				path := "";
				if(sub_dirs->Size() > 1 & (sub_dirs[0]->Has(':') | sub_dirs[0]->IsEmpty())) {
					sub_dir := sub_dirs[0];
					sub_dir->Append('/');
					sub_dir->Append(sub_dirs[1]);
					
					is_okay := Exists(sub_dir);
					if(<>is_okay) {
						is_okay := Create(sub_dir);
					};
					path->Append(sub_dir);
					path->Append('/');
					i := 2;
				};
				
				for(j := i; j < sub_dirs->Size() & is_okay; j += 1;) {
					path->Append(sub_dirs[j]);
					path->Append('/');
					
					is_okay := Exists(path);
					if(<>is_okay) {
						is_okay := Create(path);
					};
				};
				
				return is_okay;
			};
			
			return false;
		}
		
		#~
		Checks to see if the given directory exists
		@param n directory name
		@return true if directory exists
		~#
		function : Exists(n : System.String) ~ Bool {
			DIR_EXISTS;
		}
		
		#~
		List of directory content
		@param n directory name
		@return list of directory content
		~#
		function : List(n : System.String) ~ System.String[] {
			DIR_LIST;
		}
	}
}

#~
Provides network support
~#
bundle System.IO.Net {
	#~
	TCP/IP socket
	~#
	class TCPSocket implements InputStream, OutputStream {
		@handle : Int;
		@address : System.String;
		@port : Int;
		
		#~
		Default constructor
		@param address network address
		@param port network port
		~#
		New(address : System.String, port : Int) {
			Parent();
			@address := address;
			@port := port;
			SOCK_TCP_CONNECT;
		}

		#~
		Returns the connected network address
		@return return network address
		~#
		method : public : GetAddress() ~ String {
			return @address;
		}
		
		#~
		Returns the connected network port
		@return return network port
		~#
		method : public : GetPort() ~ Int {
			return @port;
		}

		#~
		Returns rather the socket is open
		@return true if socket is open, false otherwise
		~#
		method : public : IsOpen() ~ Bool {
			SOCK_TCP_IS_CONNECTED;
		}
		
		#~
		Writes a byte
		@param b byte to write
		@return true if byte was written, false otherwise
		~#
		method : public : WriteByte(b : Int) ~ Bool {
			SOCK_TCP_OUT_BYTE;
		}
		
		#~
		Writes bytes from a byte buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			SOCK_TCP_OUT_BYTE_ARY;
		}
		
		#~
		Writes characters from a character buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			SOCK_TCP_OUT_CHAR_ARY;
		}
		
		#~
		Reads a byte
		@return byte read
		~#
		method : public : ReadByte() ~ Byte {
			SOCK_TCP_IN_BYTE;
		}
		
		#~
		Reads bytes into a byte buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			SOCK_TCP_IN_BYTE_ARY;
		}
		
		#~
		Reads bytes into a character buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			SOCK_TCP_IN_CHAR_ARY;
		}
		
		#~
		Writes a character string
		@param str string to be written
		~#
		method : public : WriteString(str : System.String) ~ Nil {
			WriteString(str->ToCharArray());
		}

		method : WriteString(buffer : Char[]) ~ Nil {
			SOCK_TCP_OUT_STRING;
		}
		
		#~
		Reads a string until a newline or character return is detected 
		@return character string
		~#
		method : public : ReadString() ~ System.String {
			if(<>IsOpen()) {
				return Nil;
			};

			buffer : Char[] := Char->New[1024];
			ReadString(buffer);
			return System.String->New(buffer);
		}

		method : ReadString(buffer : Char[]) ~ Nil {
			SOCK_TCP_IN_STRING;
		}

		#~
		Reads the host name
		@return socket host name
		~#
		function : HostName() ~  System.String {
			SOCK_TCP_HOST_NAME;
		}

		#~
		List of resolved IP addresses
		@param n address name
		@return list of IP addresses
		~#
		function : Resolve(n : System.String) ~ System.String[] {
			SOCK_TCP_RESOLVE_NAME;
		}
	
		#~
		Flushes the output buffer. This is a no-opt given
		this socket is not backed by an output buffer.
		~#
		method : public : Flush() ~ Nil {}
		
		#~
		Closes the socket
		~#
		method : public : Close() ~ Nil {
			SOCK_TCP_CLOSE;
		}
	}
	
	#~
	Secure SSL TCP/IP socket
	~#
	class TCPSecureSocket implements InputStream, OutputStream {
		@ctx : Int;
		@bio : Int;
		@cert : Int;
		@is_open : Bool;
		@address : System.String;
		@port : Int;
		
		#~
		Default constructor
		@param address network address
		@param port network port
		~#
		New(address : System.String, port : Int) {
			Parent();
			@address := address;
			@port := port;
			SOCK_TCP_SSL_CONNECT;
		}

		#~
		Returns the connected network address
		@return return network address
		~#
		method : public : GetAddress() ~ String {
			return @address;
		}

		#~
		Gets the X.509 certificate's subject name
		@return certificate subject name
		~#
		method : public : GetCert() ~ String {
			SOCK_TCP_SSL_CERT;
		}
		
		#~
		Returns the connected network port
		@return return network port
		~#
		method : public : GetPort() ~ Int {
			return @port;
		}

		#~
		Returns rather the socket is open
		@return true if socket is open, false otherwise
		~#
		method : public : IsOpen() ~ Bool {
			return @is_open;		
		}
		
		#~
		Writes a byte
		@param b byte to write
		@return true if byte was written, false otherwise
		~#
		method : public : WriteByte(b : Int) ~ Bool {
			SOCK_TCP_SSL_OUT_BYTE;
		}
		
		#~
		Writes bytes from a byte buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			SOCK_TCP_SSL_OUT_BYTE_ARY;
		}
		
		#~
		Writes characters from a character buffer
		@param offset destination buffer offset
		@param num number of values to write
		@param buffer input buffer
		@return number of values written
		~#
		method : public : WriteBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			SOCK_TCP_SSL_OUT_CHAR_ARY;
		}
		
		#~
		Reads a byte
		@return byte read
		~#
		method : public : ReadByte() ~ Byte {
			SOCK_TCP_SSL_IN_BYTE;
		}
		
		#~
		Reads bytes into a byte buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Byte[]) ~ Int {
			SOCK_TCP_SSL_IN_BYTE_ARY;
		}
		
		#~
		Reads bytes into a character buffer
		@param offset destination buffer offset
		@param num number of values to read
		@param buffer input buffer
		@return number of values read
		~#
		method : public : ReadBuffer(offset : Int, num : Int, buffer : Char[]) ~ Int {
			SOCK_TCP_SSL_IN_CHAR_ARY;
		}
		
		#~
		Writes a character string
		@param str string to be written
		~#
		method : public : WriteString(str : System.String) ~ Nil {
			WriteString(str->ToCharArray());
		}

		method : WriteString(buffer : Char[]) ~ Nil {
			SOCK_TCP_SSL_OUT_STRING;
		}
		
		#~
		Reads a string until a newline or character return is detected 
		@return character string
		~#
		method : public : native : ReadString() ~ System.String {
			if(<>IsOpen()) {
				return Nil;
			};

			buffer : Char[] := Char->New[1024];
			ReadString(buffer);
			return System.String->New(buffer);
		}

		method : ReadString(buffer : Char[]) ~ Nil {
			SOCK_TCP_SSL_IN_STRING;
		}

		#~
		Flushes the output buffer. This is a no-opt given
		this socket is not backed by an output buffer.
		~#
		method : public : Flush() ~ Nil {}

		#~
		Closes the socket
		~#
		method : public : Close() ~ Nil {
			SOCK_TCP_SSL_CLOSE;
		}
	}
	
	#~
	TCP/IP Server socket
	~#
	class TCPSocketServer {
		@handle : Int;
		@port : Int;
	   
		#~
		Default constructor
		@param port server port
		~#
		New(port : Int) {
		  Parent();
		  @port := port;
		  SOCK_TCP_BIND;
		}
	
		#~
		Listens for incoming client connections
		@param backlog maximum length to queue pending connections
		@return true if client successfully connects, false otherwise
		~#
		method : public : Listen(backlog : Int) ~ Bool {
			SOCK_TCP_LISTEN;
		}
	
		#~
		Accepts a client connection
		@return client socket interface
		~#
		method : public : Accept() ~ TCPSocket {
			SOCK_TCP_ACCEPT;
		}
	
		#~
		Closes the server socket
		~#
		method : public : Close() ~ Nil {
			SOCK_TCP_CLOSE;
		}
	}
}

#~
Allow programmes to introspect the 
runtime elements
~#
bundle System.Introspection {
	#~
	Represents a runtime class
	~#
	class Class {
		@name : String;
		@methods : Method[];
	
		#~
		Creates an instance of the given class. The class must have a 
		zero-parameter constructor to support this operation.
		@param name class type name
		@return newly instantiated object instance
		~#
		function : Instance(name : System.String) ~ System.Base {
			LOAD_NEW_OBJ_INST;
		}
	
		#~
		Checks rather the class has been loaded
		@return returns true if the class has been loaded, false otherwise
		~#
		method : public : IsLoaded() ~ Bool {
			return @methods <> Nil;
		}
		
		#~
		Returns the type name of the class
		@return type name of the class
		~#
		method : public : GetName() ~ String {
			return @name;
		}
		
		#~
		Returns an array of associated methods
		@return array of associated methods
		~#
		method : public : GetMethods() ~ Method[] {
			return @methods;
		}
		
		#~
		Returns the number of methods associated 
		with the class
		@return number of methods associated with the class
		~#
		method : public : GetMethodNumber() ~ Int {
			if(@methods <> Nil) {
				return @methods->Size();
			};

			return 0;
		}
	}
	
	#~
	Represents a runtime method or function
	~#
	class Method {
		@native_mthd_ptr : Int;
		@cls : Class;
		@name : String;
		@parameters : DataType[];
		@rtrn_type  : DataType;
	
		#~
		Returns the class associated with this method
		@return associated class
		~#
		method : public : GetClass() ~ Class {
			return @cls;
		}

		#~
		Returns the name of the method
		@return name of the method
		~#
		method : public : GetName() ~ String {
			return @name;
		}
		
		#~
		Returns an array of method parameters
		@return array of method parameters
		~#
		method : public : GetParameters() ~ DataType[] {
			return @parameters;
		}
		
		#~
		Returns the method's return type
		@return method's return type
		~#
		method : public : GetReturn() ~ DataType {
			return @rtrn_type;
		}
	}
	
	#~
	Represents a runtime data type
	~#
	class DataType {
		@type  : TypeId;
		@cls_name : String;
		@dimension : Int;
		
		#~
		Returns the data type's type
		@return data type's type
		~#
		method : public : GetType() ~ TypeId {
			return @type;
		}
		
		#~
		Returns array dimension size of the data type. Will
		return 0 if type is a scalar
		@return array dimension size of the data type
		~#
		method : public : GetDimension() ~ Int {
			return @dimension;
		}
		
		#~
		Returns array the class type name
		@return class type name
		~#
		method : public : GetClassName() ~ String {
			return @cls_name;
		}
	}
	
	#~
	Data type types
	~#
	enum TypeId := -1000 {
		BOOL,
		BYTE,
		CHAR,
		INT,
		FLOAT,
		CLASS,
		FUNC
	}	
}
