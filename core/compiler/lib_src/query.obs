#~~
Single table in-memory database
Copyright (c) 2017-2020 Randy Hollines
~~#

use Collection.Generic;
use System.Time;
use Query.RegEx;
use System.IO.File;
use Data.XML;

#~
Supports processing of semi-structured data (-lib query)
~#
bundle Query.Structured {
	#~
	Container for semi-structured data
	~#
	class Table {
		@name : String;
		@keys : Map<IntHolder, Row>;
		@column_names : String[];
		@column_map : Map<String, IntHolder>;
		@head : Row;
		@tail : Row;
		@count : Int;
		@query : Query;
		
		#~
		Constructor
		@param name table name
		@param column_names column names
		~#
		New(name : String, column_names : String[]) {
			@column_map := Map->New()<String, IntHolder>;
			@keys := Map->New()<IntHolder, Row>;
			@name := name;

			@column_names := String->New[column_names->Size() + 1];
			@column_names[0] := "pk";
			@column_map->Insert(@column_names[0], 0);
			each(i : column_names) {
				@column_names[i + 1] := column_names[i];
				@column_map->Insert(@column_names[i + 1], i + 1);
			};
		}

		New(name : String, column_names : Vector<String>) {
			@column_map := Map->New()<String, IntHolder>;
			@keys := Map->New()<IntHolder, Row>;
			@name := name;
			
			@column_names := String->New[column_names->Size() + 1];
			@column_names[0] := "pk";
			@column_map->Insert(@column_names[0], 0);
			each(i : column_names) {
				@column_names[i + 1] := column_names->Get(i);
				@column_map->Insert(@column_names[i + 1], i + 1);
			};
		}
		
		#~
		Gets the table name
		@return table name
		~#
		method : public : GetName() ~ String {
			return @name;
		}
		
		#~
		Get column index by name
		@param name column name
		@return column name
		~#
		method : public : native : GetIndex(name : String) ~ Int {
			found := @column_map->Find(name);
			if(found <> Nil) {
				return found->As(IntHolder)->Get();
			};
			
			return -1;
		}
		
		#~
		Get all row1
		@return all row1
		~#
		method : public : native : GetAll() ~ Vector<Row> {
			matches := Vector->New()<Row>;
			
			row1 := @head;
			while(row1 <> Nil) {
				matches->AddBack(row1);
				row1 := row1->Next();
			};
			
			return matches;
		}
		
		#~
		Get row1 by primary key
		@param pk primary key
		@return row1
		~#
		method : public : native : Get(pk : Int) ~ Row {
			return @keys->Find(pk);
		}
		
		#~
		Gets all column names
		@return column names
		~#
		method : public : GetColumnNames() ~ String[] {
			return @column_names;
		}
		
		#~
		Gets unique rows by column name
		@param name column name
		@return unique rows
		~#
		method : public : Unique(name : String) ~ Vector<Row> {
			out := Vector->New()<Row>;
			
			index := GetIndex(name);		
			if(index < 0) {
				return out;
			};
			
			in_row := @head;
			while(in_row <> Nil) {
				left := in_row->Get(index);
				
				found := false;
				for(j := 0; found = false & j < out->Size(); j += 1;) {
					out_row := out->Get(j);
					right := out_row->Get(index);
					if(left->Compare(right) = 0) {
						found := true;
					};
				};
				
				# add
				if(<>found) {
					out->AddBack(in_row);
				};
				
				# next
				in_row := in_row->Next();
			};
			
			return out;
		}
		
		#~
		Gets the column average
		@param name column name
		@return column average
		~#
		method : public : Average(name : String) ~ Float {
			index := GetIndex(name);		
			if(index < 0) {
				return 0.0;
			};
			
			sum := 0.0;
			count := 0.0;
			row1 := @head;
			while(row1 <> Nil) {
				value := row1->Get(index);
				
				if(value->TypeOf(IntHolder)) {
					sum += value->As(IntHolder)->Get();
				}
				else if(value->TypeOf(FloatHolder)) {
					sum += value->As(FloatHolder)->Get();
				};
				
				# next
				count += 1.0;
				row1 := row1->Next();
			};
						
			return sum / count;
		}
		
		#~
		Gets the column sum
		@param name column name
		@return column sum
		~#
		method : public : Sum(name : String) ~ Float {
			index := GetIndex(name);		
			if(index < 0) {
				return 0.0;
			};
			
			sum := 0.0;
			row1 := @head;
			while(row1 <> Nil) {
				value := row1->Get(index);
				
				if(value->TypeOf(IntHolder)) {
					sum += value->As(IntHolder)->Get();
				}
				else if(value->TypeOf(FloatHolder)) {
					sum += value->As(FloatHolder)->Get();
				};
				
				# next
				row1 := row1->Next();
			};
			
			return sum;
		}
		
		#~
		Filters table based upon conditional criteria
		@param cond conditional filter
		@return filtered rows
		~#
		method : public : native : Filter(cond : Conditional) ~ Vector<Row> {
			matches := Vector->New()<Row>;
			row1 := @head;
			while(row1 <> Nil) {
				left := row1->Get(cond->GetLeft());
				if(left <> Nil) {
					right := cond->GetValue();
					select(cond->GetQualifier()) {
						label Conditional->Qualifier->EQUAL: {
							if(left->Compare(right) = 0) {
								matches->AddBack(row1);
							};
						}
						
						label Conditional->Qualifier->NOT_EQUAL: {
							if(left->Compare(right) <> 0) {
								matches->AddBack(row1);
							};
						}
						
						label Conditional->Qualifier->GREATER: {
							if(left->Compare(right) > 0) {
								matches->AddBack(row1);
							};
						}
						
						label Conditional->Qualifier->LESS: {
							if(left->Compare(right) < 0) {
								matches->AddBack(row1);
							};
						}
						
						label Conditional->Qualifier->GREATER_EQUAL: {
							if(left->Compare(right) >= 0) {
								matches->AddBack(row1);
							};
						}
						
						label Conditional->Qualifier->LESS_EQUAL: {
							if(left->Compare(right) <= 0) {
								matches->AddBack(row1);
							};
						}
						
						label Conditional->Qualifier->LIKE: {
							if(left->TypeOf(String) & right->TypeOf(String)) {
								if(MatchLike(left->As(String), right->As(String))) {
									matches->AddBack(row1);
								};
							};
						}

						label Conditional->Qualifier->NOT_LIKE: {
							if(left->TypeOf(String) & right->TypeOf(String)) {
								if(<>MatchLike(left->As(String), right->As(String))) {
									matches->AddBack(row1);
								};
							};
						}
					};
				};
				# next
				row1 := row1->Next();
			};
			
			return matches;
		}
		
		#~
		Query table using SQL-like syntax. Support for 'select', 'from', 'where', 
		'distinct', 'order by' and logical operators.
		@param statement query statement
		@return result table
		~#
		method : public : Query(statement : String) ~ Table {
			@query := Query->New(statement, @self);
			return @query->Query();
		}
		
		#~
		Gets the last query error
		@return last query error
		~#
		method : public : GetError() ~ String {
			return @query->GetError();
		}
		
		method : native : MatchLike(check : String, cond : String) ~ Bool {
			pattern := "";
			
			each(i : cond) {
				c := cond->Get(i);
				
				if(c =  '%') {
					pattern += ".*";
				}
				else if(c =  '_') {
					pattern += '.';
				}
				else {
					pattern += c;
				};
			};
			regex := RegEx->New(pattern);
			
			return regex->MatchExact(check);
		}
		
		#~
		Inserts a new row1 into the table. After the row1 
		has been added it's values will need to be set.
		@return newly inserted row1
		~#
		method : public : native : Insert() ~ Row {
			pk := IntHolder->New(@count);
			values := Compare->New[@column_names->Size()];
			values[0] := pk;
			row1 := Row->New(@self, values);
			@keys->Insert(pk->Get(), row1);
			@count += 1;
			
			if(@head = Nil) {
				@head := row1;
				@tail := row1;
			}
			else {
				@tail->Next(row1);
				row1->Prev(@tail);
				@tail := row1;
			};
			
			return row1;
		}
		
		#~
		Delete row1 by primary key
		@param pk primary key
		@return true of successful, false otherwise
		~#
		method : public : native : Delete(pk : Int) ~ Bool {
			row1 := @keys->Find(pk);
			if(row1 <> Nil) {
				if(row1 = @head) {
					@head := row1->Next();
					row1->Next(Nil);
					@head->Prev(Nil);
				}
				else if(row1 = @tail) {
					@tail := row1->Prev();
					row1->Prev(Nil);
					@tail->Next(Nil);
				}
				else {
					row1->Prev()->Next(row1->Next());
					row1->Next()->Prev(row1->Prev());
					row1->Next(Nil);
					row1->Prev(Nil);					
				};
				
				@keys->Remove(pk);
				return true;
			};
			
			return false;
		}
		
		#~
		Count of rows
		@return number of rows
		~#
		method : public : Count() ~ Int {
			return @count;
		}

		#~
		Count of rows
		@return number of rows
		~#
		method : public : Size() ~ Int {
			return @count;
		}
		
		#~
		String representation of table
		@return all row1 as a string
		~#
		method : public : ToString() ~ String {
			buffer := "";
			
			row1 := @head;
			while(row1 <> Nil) {
				buffer += row1->ToString();
				buffer += "\r\n";
				row1 := row1->Next();
			};
			
			return buffer;
		}

		#~
		Loads a table from a CSV file
		@param table_name table name
		@param path to CSV
		@return new table
		~#
		function : FromCsv(table_name : String, path : String) ~ Table {
			csv := Data.CSV.CsvTable->New(FileReader->ReadFile(path));
			
			if(csv->IsParsed() & csv->Size() > 1) {
				headers := csv->Get(0);
				columns := String->New[headers->Size()];
				each(i : headers) {	
					columns[i] := headers->Get(i);
				};

				table := Query.Structured.Table->New(table_name, columns);
				for(i := 1; i < csv->Size(); i += 1;) {
					column := csv->Get(i);
					row1 := table->Insert();
					for(j := 0; j < columns->Size(); j += 1;) {
						# clean up value
						str_value := column->Get(j);

						# digit
						if(str_value->Size() > 0 & str_value->Get(0)->IsDigit()) {
							# float
							if(str_value->Has('.')) {
								row1->Set(j + 1, FloatHolder->New(str_value->ToFloat()));
							}
							# int
							else {
								row1->Set(j + 1, IntHolder->New(str_value->ToInt()));
							};
						}
						# date
						else if(str_value->StartsWith('#') & str_value->EndsWith('#')) {
							str_value := str_value->SubString(1, str_value->Size() - 2);
							select(str_value->Size()) {
								label 8: {
									date := DateUtility->Parse(str_value, "MM/dd/yy", false);
									row1->Set(j + 1, date);
								}
								
								label 10: {						
									date := DateUtility->Parse(str_value, "MM/dd/yyyy", false);	
									row1->Set(j + 1, date);
								}
								
								label 17: {
									date := DateUtility->Parse(str_value, "MM/dd/yy hh:mm:ss", false);
									row1->Set(j + 1, date);
								}
								
								label 19: {
									date := DateUtility->Parse(str_value, "MM/dd/yyyy hh:mm:ss", false);
									row1->Set(j + 1, date);
								}
								
								other: {
									row1->Set(j + 1, str_value);
								}
							};
						}
						# string
						else {
							row1->Set(j + 1, str_value);
						};
					};
				};

				return table->Size() > 1 ? table : Nil;
			};
			
			"Unable to parse {$path}!"->ErrorLine();
			return Nil;
		}

		#~
		Loads a table from a directory file system. Columns are: path_name, create_date, owner, is_dir and is_readonly.
		@param table_name table name
		@param path to directory
		@return new table
		~#
		function : FromFilesystem(table_name : String, path : String) ~ Table {
			table := Table->New(table_name, ["name", "path_name", "create_date", "owner", "is_dir", "is_readonly"]);

			if(<>path->EndsWith('/')  <>path->EndsWith('\\')) {
				path += '/';
			};

			files := Directory->List(path);
			each(i : files) {
				short_name := files[i];
				long_name := String->New(path); 
				long_name += short_name;
				file_owner := File->Owner(long_name);
				create_date := File->CreateTime(long_name);
				is_dir := Directory->Exists(long_name);
				is_readonly := File->IsReadOnly(long_name);
				
				row1 := table->Insert();
				row1->Set("name", short_name);
				row1->Set("path_name", long_name);
				row1->Set("create_date", create_date);
				row1->Set("owner", file_owner);
				row1->Set("is_dir", is_dir ? Row->True() : Row->False());
				row1->Set("is_readonly", is_readonly ? Row->True() : Row->False());
			};
			
			return table;	
		}
	}
	
	#~
	Conditional for filtering
	~#
	class : private : Conditional {
		@left : Int;
		@qualifier : Conditional->Qualifier;
		@value : Compare;
		
		#~
		Conditional comparisons 
		~#
		enum Qualifier {
			EQUAL,
			NOT_EQUAL,
			GREATER,
			LESS,
			GREATER_EQUAL,
			LESS_EQUAL,
			LIKE,
			NOT_LIKE
		}
		
		#~
		Constructor
		@param left index of column to compare
		@param qualifier comparison type
		@param value to compare against column
		~#
		New(left : Int, qualifier : Conditional->Qualifier, value : Compare) {
			@left := left;
			@qualifier := qualifier;
			@value := value;
		}
		
		#~
		Get the qualifying value
		@return qualifying value
		~#
		method : public : GetQualifier() ~ Qualifier {
			return @qualifier;
		}
		
		#~
		Gets the comparison value
		@return comparison value
		~#
		method : public : GetValue() ~ Compare {
			return @value;
		}
		
		#~
		Gets comparison index
		@return comparison index
		~#
		method : public : GetLeft() ~ Int {
			return @left;
		}
	}
	
	#~
	Row in table
	~#
	class Row {
		@values : Compare[];
		@table : Table;
		@true_token : static : IntHolder;
		@false_token : static : IntHolder;
		@next : Row;
		@prev : Row;
		
		New(table : Table, values : Compare[]) {
			@table := table;
			@values := values;
		}
		
		#~
		Gets value by name
		@param name column name
		@return value
		~#
		method : public : Get(name : String) ~ Compare {
			return Get(@table->GetIndex(name));
		}
		
		#~
		Sets value by name
		@param name column name
		@param value value
		@return ture of successful, false otherwise
		~#
		method : public : Set(name : String, value : Compare) ~ Bool {
			return Set(@table->GetIndex(name), value);
		}
		
		#~
		Gets value by index
		@param index column index
		@return value
		~#
		method : public : Get(index : Int) ~ Compare {
			if(index < 0 | index >= @values->Size()) {
				return Nil;
			};
			
			return @values[index];
		}
		
		#~
		Sets value by index
		@param index column index
		@param value value
		@return ture of successful, false otherwise
		~#
		method : public : Set(index : Int, value : Compare) ~ Bool {
			if(index < 0 | index >= @values->Size()) {
				return false;
			};
			
			@values[index] := value;
			return true;
		}
		
		#~
		Helper for setting 'true' column value
		@return 'true' value holder
		~#
		function : True() ~ IntHolder {
			if(@true_token = Nil) {
				@true_token := IntHolder->New(1);
			};
			
			return @true_token;
		}
		
		#~
		Helper for setting 'false' column value
		@return 'false' value holder
		~#
		function : False() ~ IntHolder {
			if(@false_token = Nil) {
				@false_token := IntHolder->New(0);
			};
			
			return @false_token;
		}
			
		method : public : Next() ~ Row {
			return @next;
		}
		
		method : public : Next(next : Row) ~ Nil {
			@next := next;
		}
		
		method : public : Prev() ~ Row {
			return @prev;
		}
		
		method : public : Prev(prev : Row) ~ Nil {
			@prev := prev;
		}
		
		#~
		Gets the number of columns
		@return number of columns
		~#
		method : public : Size() ~ Int {
			return @values->Size();
		}
		
		#~
		String representation of row1
		@return row1 as string
		~#
		method : public : ToString() ~ String {
			buffer := "";

			each(i : @values) {
				value := @values[i];
				
				if(value <> Nil) {
					if(value->TypeOf(IntHolder)) {
						buffer += value->As(IntHolder)->ToString();
					}
					else if(value->TypeOf(FloatHolder)) {
						buffer += value->As(FloatHolder)->ToString();
					}
					else if(value->TypeOf(Date)) {
						buffer += value->As(Date)->ToString();
					}
					else if(value->TypeOf(String)) {
						buffer += value->As(String);
					}
					else {
						buffer += value->GetClass()->GetName();
					};
				}
				else {
						buffer += "<Nil>";
				};	
					
				buffer += ", ";
			};
			
			return buffer;
		}
	}
	
	class Query {
		@parser : Parser;
		@terms : Term;
		@table : Table;
		@error : String;
		
		New(line : String, table : Table) {
			@table := table;
			@parser := Parser->New(line);
		}
		
		method : public : Query() ~ Table {
			expr := @parser->Parse();
			if(expr = Nil) {
				@error := "*** Parse error ***";
				return Nil;
			};
			
			if(expr->GetType() = Token->Type->SELECT) {

				results := ProcessSelect(expr);
				if(results = Nil) {
					@error := "*** Select error ***";
					return Nil;
				};
				
				return results;
			}
			else if(expr->GetType() = Token->Type->FROM) {
				results := ProcessFrom(expr)<Row>;
				if(results = Nil) {
					@error := "*** From error ***";
					return Nil;
				};
				
				names := @table->GetColumnNames();
				column_names := String->New[names->Size() - 1];
				each(i : column_names) {
					column_names[i] := names[i + 1];
				};
								
				return BuildTable("<rs>", column_names, results, Nil);				
			}
			else {
				@error := "*** General error ***";
				return Nil;
			};
			
			return Nil;
		}

		method : public : GetError() ~ String {
			return @error;
		}
		
		method : ProcessSelect(expr : Term) ~ Table {
# "== Select =="->PrintLine();
			results := ProcessFrom(expr->GetLeft());
			if(results = Nil) {
				return Nil;
			};
			columns := expr->GetTerms();
						
			column_names : String[];
			if(columns->Size() = 1 & columns->Get(0)->As(Term)->GetType() = Token->Type->STAR) {
				names := @table->GetColumnNames();
				column_names := String->New[names->Size() - 1];
				each(i : column_names) {
					column_names[i] := names[i + 1];
				};
			}
			else if(columns->Size() = 2 & 
					columns->Get(0)->As(Term)->GetType() = Token->Type->DISTINCT & 
					columns->Get(1)->As(Term)->GetType() = Token->Type->REF) {
				column_names := String->New[1];
				column_name := columns->Get(1)->As(Term)->GetValue()->As(String);
				column_names[0] := column_name;
				results := Unique(column_name, results);
			}
			else {
				column_names := String->New[columns->Size()];
				each(i : columns) {
					column_names[i] := columns->Get(i)->As(Term)->GetValue()->As(String);
				};
			};

			if(expr->GetRight() <> Nil) {
				order_by := expr->GetRight()->GetValue()->As(String);
				return BuildTable("<rs>", column_names, results, order_by);
			};
						
			return BuildTable("<rs>", column_names, results, Nil);
		}
		
		method : Unique(col : String, in : Vector<Row>) ~ Vector<Row> {
			out := Vector->New()<Row>;
			
			index := @table->GetIndex(col);
			if(index < 0) {
				return out;
			};
			
			each(i : in) {
				in_row := in->Get(i);
				left := in_row->Get(index);
				
				found := false;
				for(j := 0; found = false & j < out->Size(); j += 1;) {
					out_row := out->Get(j);
					right := out_row->Get(index);
					if(left->Compare(right) = 0) {
						found := true;
					};
				};
				
				if(<>found) {
					out->AddBack(in_row);
				};
			};
			
			return out;
		}
		
		method : BuildTable(name : String, column_names : String[], from_results : Vector<Row>, order_by : String) ~ Table {
			table := Table->New(name, column_names);

			if(order_by <> Nil) {
				order_index := @table->GetIndex(order_by);
				if(order_index > -1) {
					ordered_values := Map->New()<Compare, Row>;
					each(i : from_results) {
						row1 := from_results->Get(i);
						ordered_values->Insert(row1->Get(order_index), row1);
					};
					from_results := ordered_values->GetValues()<Row>;
				};
			};
			
			each(i : from_results) {
				row1 := from_results->Get(i);
				result_row := table->Insert();
				each(j : column_names) {
					column_name := column_names[j];
					result_row->Set(column_name, row1->Get(column_name));
				};
			};

			return table;
		}
		
		method : ProcessFrom(expr : Term) ~ Vector<Row> {
# "== From =="->PrintLine();
			
			name := expr->GetValue()->As(String);
			if(<>name->Equals(@table->GetName())) {
				return Nil;
			};
			
			# where
			left := expr->GetLeft();
			if(left <> Nil & left->GetType() = Token->Type->WHERE) {
				return ProcessTerm(left->GetLeft());
			}
			else {
				return @table->GetAll();
			};
		}
		
		method : ProcessTerm(expr : Term) ~ Vector<Row> {
			if(expr = Nil) {
				return Nil;
			};

			left := expr->GetLeft();
			right := expr->GetRight();
			if(left = Nil | right = Nil) {
 				return Nil;
 			};
			
			select(expr->GetType()) {
				label Token->Type->AND: {
# "== And =="->PrintLine();		
					left_result := ProcessTerm(left);
					if(left_result = Nil) {
						return Nil;
					};

					right_result := ProcessTerm(right);
					if(right_result = Nil) {
						return Nil;
					};

					return MergeAnd(left_result, right_result);
				}
				
				label Token->Type->OR: {
# "== Or =="->PrintLine();		
					left_result := ProcessTerm(left);
					if(left_result = Nil) {
						return Nil;
					};

					right_result := ProcessTerm(right);
					if(right_result = Nil) {
						return Nil;
					};

					return MergeOr(left_result, right_result);
				}
				
				label Token->Type->EQUAL: {	
					index := @table->GetIndex(left->GetValue()->As(String));
# "== Equal =="->PrintLine();
 					if(index > -1) {
 						if(expr->GetNot()) {
 							return @table->Filter(Conditional->New(index, Conditional->Qualifier->NOT_EQUAL, right->GetValue()));
 						}
 						else {
							return @table->Filter(Conditional->New(index, Conditional->Qualifier->EQUAL, right->GetValue()));
						};
 					};
				}
				
				label Token->Type->NOT_EQUAL: {
# "== Not equal =="->PrintLine();
					index := @table->GetIndex(left->GetValue()->As(String));
 					if(index > -1) {
						return @table->Filter(Conditional->New(index, Conditional->Qualifier->NOT_EQUAL, right->GetValue()));
					};
				}
				
				label Token->Type->GREATER: {
# "== Greater =="->PrintLine();
					index := @table->GetIndex(left->GetValue()->As(String));
 					if(index > -1) {
						return @table->Filter(Conditional->New(index, Conditional->Qualifier->GREATER, right->GetValue()));
					};
				}
				
				label Token->Type->LESS: {
# "== Less =="->PrintLine();
					index := @table->GetIndex(left->GetValue()->As(String));
 					if(index > -1) {
						return @table->Filter(Conditional->New(index, Conditional->Qualifier->LESS, right->GetValue()));
					};
				}
				
				label Token->Type->GREATER_EQUAL: {
# "== Greater =="->PrintLine();
					index := @table->GetIndex(left->GetValue()->As(String));
 					if(index > -1) {
						return @table->Filter(Conditional->New(index, Conditional->Qualifier->GREATER_EQUAL, right->GetValue()));
					};
				}
				
				label Token->Type->LESS_EQUAL: {
# "== Less =="->PrintLine();
					index := @table->GetIndex(left->GetValue()->As(String));
 					if(index > -1) {
						return @table->Filter(Conditional->New(index, Conditional->Qualifier->LESS_EQUAL, right->GetValue()));
					};
				}
				
				label Token->Type->LIKE: {
					is_not := expr->GetNot();
# "== Like: is_not={$is_not} =="->PrintLine();

					index := @table->GetIndex(left->GetValue()->As(String));
 					if(index > -1) {
 						if(is_not) {
 							return @table->Filter(Conditional->New(index, Conditional->Qualifier->NOT_LIKE, right->GetValue()));
 						}
 						else {
							return @table->Filter(Conditional->New(index, Conditional->Qualifier->LIKE, right->GetValue()));
						};
					};
				}
			};
			
			return Nil;
		}
		
		method : MergeAnd(left : Vector<Row>, right : Vector<Row>) ~ Vector<Row> {
			merged := Vector->New()<Row>;
			
			if(left <> Nil & right <> Nil) {
				each(i : right) {
					right_value := right->Get(i);
					
					found := false;
					for(j := 0; found = false & j < left->Size(); j += 1;) {
						left_value := left->Get(j);
						if(left_value = right_value) {
							found := true;
						};
					};
					
					if(found) {
						merged->AddBack(right_value);
					};
				};
			};
			
			return merged;
		}
		
		method : MergeOr(left : Vector<Row>, right : Vector<Row>) ~ Vector<Row> {
			if(left <> Nil & right <> Nil) {
				each(i : right) {
					right_value := right->Get(i);
					
					not_found := false;
					for(j := 0; not_found = false & j < left->Size(); j += 1;) {
						left_value := left->Get(j);
						if(left_value <> right_value) {
							not_found := true;
						};
					};
					
					if(not_found) {
						left->AddBack(right_value);
					};
				};
			};
			
			return left;
		}
	}
	
	class Parser {
		@line : String;
		@tokens : Vector<Token>;
		@tokens_index : Int;
		@cur_token : Token;
		
		New(line : String) {
			@line := line;
		}
		
		method : public : Parse() ~ Term {
			@tokens := Scan();

			term : Term;
			if(@tokens = Nil)	{
				return Nil;
			};			
			NextToken();

			if(TokenType() = Token->Type->SELECT) {
				NextToken();		
				term := ParseSelect();
			}
			else if(TokenType() = Token->Type->FROM) {
				NextToken();
				term := ParseFrom();
			};

			if(term <> Nil & TokenType() = Token->Type->ORDER) {
				NextToken();

				if(TokenType() <> Token->Type->BY) {
					return Nil;
				};
				NextToken();

				if(TokenType() <> Token->Type->REF) {
					return Nil;
				};

				right := Term->New(TokenType());
				right->SetValue(TokenValue());
				term->SetRight(right);
			};
			
			return term;
		}
		
		method : ParseSelect() ~ Term {
# "--- Select ---"->PrintLine();		
			term := Term->New(Token->Type->SELECT);
			term->SetValue(TokenValue());
			
			if(TokenType() = Token->Type->STAR) {
				term->AddTerm(Term->New(TokenType()));
				NextToken();		
			}
			else if(TokenType() = Token->Type->DISTINCT) {
				term->AddTerm(Term->New(TokenType()));
				NextToken();
				
				if(TokenType() <> Token->Type->REF) {
					return Nil;
				};
				name := Term->New(TokenType());
				name->SetValue(TokenValue());
				term->AddTerm(name);
				NextToken();
			}
			else {
				do {
					if(TokenType() <> Token->Type->REF) {
						return Nil;
					};
					name := Term->New(TokenType());
					name->SetValue(TokenValue());
					term->AddTerm(name);
					NextToken();

				
					if(TokenType() = Token->Type->COMMA) {
						NextToken();
					};
				}
				while(TokenType() <> Token->Type->EOS & TokenType() <> Token->Type->FROM);
			};
			
			if(TokenType() <> Token->Type->FROM) {			
				return Nil;
			};
			
			NextToken();
			left := ParseFrom();
			if(left = Nil) {			
				return Nil;
			};
			term->SetLeft(left);

			return term;
		}

		method : ParseFrom() ~ Term {
# "--- From ---"->PrintLine();

			if(TokenType() <> Token->Type->REF) {
				return Nil;
			};
			term := Term->New(Token->Type->FROM);
			term->SetValue(TokenValue());
			NextToken();
			
			if(TokenType() = Token->Type->WHERE) {
				NextToken();
				left := ParseWhere();
				if(left = Nil) {
					return Nil;
				};
				term->SetLeft(left);
			};
			
			term->SetRight(Term->New(Token->Type->EOS));
			return term;
		}

		method : public : ParseWhere() ~ Term {
# "--- Where ---"->PrintLine();
			
			where := Term->New(Token->Type->WHERE);
			
			left := ParseLogic();
			do {
				type := TokenType();
				if(type = Token->Type->AND | type = Token->Type->OR) {
					term := Term->New(type);
					term->SetValue(TokenValue());
					NextToken();
					
					right := ParseTerm();
					if(right = Nil) {
						return Nil;
					};
					
					term->SetLeft(left);
					term->SetRight(right);
					left := term;
				}
				else {
					NextToken();
				};
			}
			while(TokenType() <> Token->Type->EOS);
			
			where->SetLeft(left);
			return where;
		}
		
		method : ParseLogic() ~ Term {
			left := ParseTerm();
			if(left = Nil) {
				return Nil;
			};
			
			type := TokenType();
			if(type = Token->Type->AND | type = Token->Type->OR) {
# "--- Logic ---"->PrintLine();
			
				term := Term->New(type);
				term->SetValue(TokenValue());
				NextToken();
				
				right := ParseTerm();
				if(right = Nil) {
					return Nil;
				};
				
				term->SetLeft(left);
				term->SetRight(right);
				return term;
			};

			return left;
		}
		
		method : ParseTerm() ~ Term {
# "--- Term ---"->PrintLine();
			
			left : Term;
			select(TokenType()) {
				label Token->Type->REF:
				label Token->Type->DATE:
				label Token->Type->INT:
				label Token->Type->FLOAT: {				
					left := Term->New(TokenType());
					left->SetValue(TokenValue());
					NextToken();
				}
				
				label Token->Type->OPRN: {
					NextToken();
					
					left := ParseLogic();
					do {
						type := TokenType();
						if(type = Token->Type->AND | type = Token->Type->OR) {
							term := Term->New(type);
							term->SetValue(TokenValue());
							NextToken();
							
							right := ParseTerm();
							if(right = Nil) {
								return Nil;
							};
							
							term->SetLeft(left);
							term->SetRight(right);
							left := term;
						}
						else {
							NextToken();
						};
					}
					while(TokenType() <> Token->Type->EOS);

					return left;
				}
				
				other: {
					return Nil;
				}
			};

			is_not := false;
			if(TokenType() = Token->Type->NOT) {
				is_not := true;
				NextToken();		
			};
			
			term : Term;
			select(TokenType()) {
				label Token->Type->LIKE:
				label Token->Type->EQUAL:
				label Token->Type->NOT_EQUAL:
				label Token->Type->LESS:
				label Token->Type->GREATER:
				label Token->Type->LESS_EQUAL:
				label Token->Type->GREATER_EQUAL: {				
					term := Term->New(TokenType());
					term->SetValue(TokenValue());
					term->SetNot(is_not);
					NextToken();
				}

				other: {
					return Nil;
				}
			};
			
			right : Term;			
			select(TokenType()) {
				label Token->Type->REF:
				label Token->Type->DATE:
				label Token->Type->INT:
				label Token->Type->FLOAT: {			
					right := Term->New(TokenType());					
					right->SetValue(TokenValue());
					NextToken();
				}
				
				other: {
					return Nil;
				}
			};
		
			term->SetLeft(left);
			term->SetRight(right);
			
			return term;
		}
		
		method : NextToken() ~ Bool {
			if(@tokens_index < @tokens->Size()) {
				@cur_token := @tokens->Get(@tokens_index);
				@tokens_index += 1;
				return true;
			};
			
			@cur_token := Nil;
			return false;
		}
		
		method : TokenType() ~ Token->Type {
			if(@cur_token <> Nil) {
				return @cur_token->GetType();
			};
			
			return Token->Type->EOS;
		}
		
		method : TokenValue() ~ Compare {
			if(@cur_token <> Nil) {
				return @cur_token->GetValue();
			};
			
			return "";
		}
		
		method : native : Scan() ~ Vector<Token> {		
			reserved := Map->New()<String, Token>;
			reserved->Insert("select", Token->New(Token->Type->SELECT));
			reserved->Insert("distinct", Token->New(Token->Type->DISTINCT));
			reserved->Insert("from", Token->New(Token->Type->FROM));
			reserved->Insert("where", Token->New(Token->Type->WHERE));
			reserved->Insert("not", Token->New(Token->Type->NOT));
			reserved->Insert("like", Token->New(Token->Type->LIKE));
			reserved->Insert("between", Token->New(Token->Type->BETWEEN));
			reserved->Insert("in", Token->New(Token->Type->IN));
			reserved->Insert("and", Token->New(Token->Type->AND));
			reserved->Insert("or", Token->New(Token->Type->OR));
			reserved->Insert("true", Token->New(1));
			reserved->Insert("false", Token->New(0));
			reserved->Insert("order", Token->New(Token->Type->ORDER));
			reserved->Insert("by", Token->New(Token->Type->BY));
			
			i := 0;
			tokens := Vector->New()<Token>;
			while(i < @line->Size()) { 			 			  
				# skip whitespace
				while(i < @line->Size() & (@line->Get(i) = ' ' | @line->Get(i) = '\t' | @line->Get(i) = '\r' | @line->Get(i) = '\n')) {
					i += 1;					
				};
				
				# parse the @line
				if(i < @line->Size()) {
					# string
					if(@line->Get(i) = '\'') {
						string := "";
						i += 1;
						while(i < @line->Size() & @line->Get(i) <> '\'') {
							string->Append(@line->Get(i));
							i += 1;
						};
						
						if(@line->Get(i) <> '\'') {
							return Nil;
						};
						i += 1;
						
						tokens->AddBack(Token->New(string));
					}
					# date
					else if(@line->Get(i) = '#') {
						i += 1;					
						string := "";
						while(i < @line->Size() & @line->Get(i) <> '#') {
							string->Append(@line->Get(i));
							i += 1;
						};
					
						if(@line->Get(i) <> '#') {
							return Nil;
						};
						i += 1;
						
						select(string->Size()) {
							label 8: {
								date := DateUtility->Parse(string, "MM/dd/yy", false);
								tokens->AddBack(Token->New(date));
							}
							
							label 10: {						
								date := DateUtility->Parse(string, "MM/dd/yyyy", false);	
								tokens->AddBack(Token->New(date));
							}
							
							label 17: {
								date := DateUtility->Parse(string, "MM/dd/yy hh:mm:ss", false);
								tokens->AddBack(Token->New(date));
							}
							
							label 19: {
								date := DateUtility->Parse(string, "MM/dd/yyyy hh:mm:ss", false);
								tokens->AddBack(Token->New(date));
							}
							
							other: {
								return Nil;
							}
						};
					}
					# word
					else if(@line->Get(i)->IsChar() = true) {
						string := "";
						while(i < @line->Size() & @line->Get(i)->IsChar() | @line->Get(i) = '_') {
							string->Append(@line->Get(i));
							i += 1;
						};

						result := reserved->Find(string->ToLower());
						if(result <> Nil) {
							tokens->AddBack(result);
						}
						else {
							tokens->AddBack(Token->New(string));
						};
					}
					# number
					else if(@line->Get(i)->IsDigit() = true) {
						number := "";
						is_dec := 0;
						while(i < @line->Size() & @line->Get(i)->IsDigit() = true | @line->Get(i) = '.') {
							if(@line->Get(i) = '.') {
								is_dec += 1;
							};
							number->Append(@line->Get(i));
							i += 1;
						};

						if(is_dec = 1) {
							tokens->AddBack(Token->New(number->ToFloat()));
						}
						else if(is_dec = 0) {
							tokens->AddBack(Token->New(number->ToInt()));
						}
						else {
							return Nil;
						};
					}
					# other
					else {
						select(@line->Get(i)) {
							label '*': {
								tokens->AddBack(Token->New(Token->Type->STAR));
							}

							label ',': {
								tokens->AddBack(Token->New(Token->Type->COMMA));
							}
							
							label '(': {
								tokens->AddBack(Token->New(Token->Type->OPRN));
							}
							
							label ')': {
								tokens->AddBack(Token->New(Token->Type->CPRN));
							}
							
							label '=': {
								tokens->AddBack(Token->New(Token->Type->EQUAL));
							}
							
							label '<': {
								if(@line->Get(i + 1) = '>') {
									i += 1;
									tokens->AddBack(Token->New(Token->Type->NOT_EQUAL));
								}
								else if(@line->Get(i + 1) = '=') {
									i += 1;
									tokens->AddBack(Token->New(Token->Type->LESS_EQUAL));
								}
								else {
									tokens->AddBack(Token->New(Token->Type->LESS));
								};
							}
							
							label '>': {
								if(@line->Get(i + 1) = '=') {
									i += 1;
									tokens->AddBack(Token->New(Token->Type->GREATER_EQUAL));
								}
								else {
									tokens->AddBack(Token->New(Token->Type->GREATER));
								};
							}
              
							other: {
								return Nil;
							}
						};
						i += 1;
					};
				};			
			};			
			tokens->AddBack(Token->New(Token->Type->EOS));

			return tokens;
		}
	}
	
	class Term {
		@type : Token->Type;
		@oper : Conditional->Qualifier;
		@left : Term;
		@right : Term;
		@terms : Vector<Term>;
		@value : Compare;
		@is_not : Bool;

		
		New(type : Token->Type) {
			@type := type;
		}
		
		method : public : GetType() ~ Token->Type {
			return @type;
		}
		
		method : public : SetType(type : Token->Type) ~ Nil {
			@type := type;
		}

		method : public : GetNot() ~ Bool {
			return @is_not;
		}
		
		method : public : SetNot(is_not : Bool) ~ Nil {
			@is_not := is_not;
		}
		
		method : public : GetOperator() ~ Conditional->Qualifier {
			return @oper;
		}
		
		method : public : SetOperator(oper : Conditional->Qualifier) ~ Nil {
			@oper := oper;
		}
		
		method : public : SetValue(value : Compare) ~ Nil {
			@value := value;
		}
		
		method : public : GetValue() ~ Compare {
			return @value;
		}
		
		method : public : SetLeft(left : Term) ~ Nil {
			@left := left;
		}
		
		method : public : GetLeft() ~ Term {
			return @left;
		}
		
		method : public : SetRight(right : Term) ~ Nil {
			@right := right;
		}
		
		method : public : GetRight() ~ Term {
			return @right;
		}
		
		method : public : AddTerm(term : Term) ~ Nil {
			if(@terms = Nil) {
				@terms := Vector->New()<Term>;
			};
			
			@terms->AddBack(term);
		}
		
		method : public : GetTerms() ~ Vector<Term> {
			return @terms;
		}
	}
	
	class Token {
		@type : Type;
		@value : Compare;

		enum Type {
			SELECT,
			DISTINCT,
			FROM,
			WHERE,
			LIKE,
			NOT,
			BETWEEN,
			IN,
			AND,
			OR,
			ORDER,
			BY,
			STAR,
			COMMA,
			OPRN,
			CPRN,
			EQUAL,
			NOT_EQUAL,
			LESS_EQUAL,
			LESS,
			GREATER_EQUAL,
			GREATER,
			REF,
			OPER,
			INT,
			FLOAT,
			DATE,
			TRUE,
			FASLE,
			EOS
		}
		
		New(value : String) {
			@type := Type->REF;
			@value := value;
		}
		
		New(value : Date) {
			@type := Type->DATE;
			@value := value;
		}
		
		New(type : Type) {
			@type := type;
			@value := "";
		}
		
		New(value : Float) {
			@type := Type->FLOAT;
			@value := FloatHolder->New(value);
		}

		New(value : Int) {
			@type := Type->INT;
			@value := IntHolder->New(value);
		}
		
		method : public : GetType() ~ Type {
			return @type;
		}
		
		method : public : GetValue() ~ Compare {
			return @value;
		}

		method : public : ToString() ~ String {
			buffer := "";

			select(@type) {
				label Type->SELECT: {
					buffer += "SELECT";
				}

				label Type->DISTINCT: {
					buffer += "DISTINCT";
				}
				
				label Type->FROM: {
					buffer += "FROM";
				}

				label Type->WHERE: {
					buffer += "WHERE";
				}

				label Type->LIKE: {
					buffer += "LIKE";
				}

				label Type->NOT: {
					buffer += "NOT";
				}

				label Type->BETWEEN: {
					buffer += "BETWEEN";
				}

				label Type->IN: {
					buffer += "IN";
				}

				label Type->AND: {
					buffer += "AND";
				}

				label Type->OR: {
					buffer += "OR";
				}

				label Type->STAR: {
					buffer += "STAR";
				}

				label Type->ORDER: {
					buffer += "ORDER";
				}

				label Type->BY: {
					buffer += "BY";
				}

				label Type->COMMA: {
					buffer += "COMMA";
				}

				label Type->OPRN: {
					buffer += "OPRN";
				}
				
				label Type->CPRN: {
					buffer += "CPRN";
				}

				label Type->EQUAL: {
					buffer += "EQUAL";
				}

				label Type->NOT_EQUAL: {
					buffer += "NOT_EQUAL";
				}

				label Type->LESS_EQUAL: {
					buffer += "LESS_EQUAL";
				}

				label Type->LESS: {
					buffer += "LESS";
				}

				label Type->GREATER_EQUAL: {
					buffer += "GREATER_EQUAL";
				}

				label Type->GREATER: {
					buffer += "GREATER";
				}

				label Type->REF: {
					buffer += "REF, value='";
					buffer += @value->As(String);
					buffer += '"';
				}

				label Type->INT: {
					buffer += "INT, value=";
					buffer += @value->As(IntHolder)->Get();
				}

				label Type->FLOAT: {
					buffer += "FLOAT, value=";
					f := @value->As(FloatHolder);
					buffer += f->Get();
				}

				label Type->EOS: {
					buffer += "EOS";
				}
			};

			return buffer;
		}
	}

	#~
	Supports string data queries
	~#
	class Finder {
		@regex : RegEx;

		#~
		Default constructor
		@param expr regex expression
		~#
		New(expr : String) {
			@regex := RegEx->New(expr);
		}

		#~
		Finds matching files in a given directory
		@param path root directory to start searching
		@return matching file names
		~#
		method : public : FindFiles(path : String) ~ Vector<String> {
			matches := Vector->New()<String>;

			if(@regex->IsOk()) {
				FindFiles(path, matches);
			};
			
			return matches;
		}

		method : FindFiles(path : String, matches : Vector<String>) ~ Nil {
			files := Directory->List(path);
			each(i : files) {
				file := files[i];
				if(<>file->StartsWith('.')) {
					dir_path := String->New(path);
					dir_path += '/';
					dir_path += file;
					
					if(Directory->Exists(dir_path)) {
						FindFiles(dir_path, matches);
					}
					else if(File->Exists(dir_path)) {
						full_name := File->GetFullName(dir_path);
						if(@regex->MatchExact(full_name)) {
							matches->AddBack(full_name);
						};
					};
				};
			};
		}
	}
}
