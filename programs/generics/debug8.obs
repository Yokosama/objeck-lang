class Foo {
	function : Main(args : String[]) ~ Nil {
		m := Map->New()<String, IntHolder>;
		
		m->Add("a", IntHolder->New(1));
		m->Add("o", 13);
		m->Add("r", IntHolder->New(18));
		m->Add("h", 'c');

		m->Get("h")->Get()->PrintLine();
		m->Get("o")->Get()->PrintLine();
		m->Get("b")->Get()->PrintLine();

		m->Apply(Concat(IntHolder) ~ IntHolder);

		m->Get("h")->Get()->PrintLine();
		m->Get("o")->Get()->PrintLine();
		
		m->Get("b")->Get()->PrintLine();
	}

	# TODO: Unbox testing
	function : Funk() ~ Int {
		return IntHolder->New(13);
	}

	function : Concat(i : IntHolder) ~ IntHolder {
		return i + 13;
#		return IntHolder->New(i + 13);
	}
}

class Node<K : Compare, V> {
	@key : K;
	@value : V;
	@left : Node<K,V>;
	@right : Node<K,V>;

	New(key : K, value : V) {
		@key := key;
		@value := value;
	}

	method : public : GetKey() ~ K {
		return @key;
	}

	method : public : GetValue() ~ V {
		return @value;
	}

	method : public : SetValue(value : V) ~ Nil {
		@value := value;
	}

	method : public : SetLeft(left : Node<K, V>) ~ Nil {
		@left := left;
	}

	method : public : GetLeft() ~ Node<K, V> {
		return @left;
	}

	method : public : SetRight(right : Node<K, V>) ~ Nil {
		@right := right;
	}

	method : public : GetRight() ~ Node<K, V> {
		return @right;
	}
}

class Map<K : Compare, V> {
	@root : Node<K, V>;
	@size : Int;

	New() {
	}

	method : public : Add(key : K, value : V) ~ Bool {
		if(@root = Nil) {
			@root := Node->New(key, value)<K, V>;
			@size += 1; 
			return true;
		}
		else if(Add(@root, Node->New(key, value)<K, V>)) {
		 	@size += 1;
		 	return true;
		};

		return false;
	}

	method : Add(current : Node<K,V>, node : Node<K,V>) ~ Bool {
		compare := current->GetKey()->Compare(node->GetKey());
		if(compare < 0) {
			if(current->GetLeft() <> Nil) {
				Add(current->GetLeft(), node);	
			}
			else {
				current->SetLeft(node);
				return true;
			};
		}
		else if(compare > 0) {
			if(current->GetRight() <> Nil) {
				Add(current->GetRight(), node);	
			}
			else {
				current->SetRight(node);
				return true;
			};
		};

		return false;
	}

	method : public : Apply(func : (V) ~ V) ~ Nil {
		Apply(@root, func);
	}

	method : Apply(current : Node<K,V>, func : (V) ~ V) ~ Nil {
		if(current->GetLeft() <> Nil) {
			Apply(current->GetLeft(), func);
		};

		if(current->GetRight() <> Nil) {
			Apply(current->GetRight(), func);	
		};

		current->SetValue(func(current->GetValue()));
	}

	method : public : Get(key : K) ~ V {
		return Get(@root, key);
	}

	method : Get(current : Node<K,V>, key : K) ~ V {
		compare := current->GetKey()->Compare(key);
		if(compare < 0 & current->GetLeft() <> Nil) {
			return Get(current->GetLeft(), key);
		}
		else if(compare > 0 & current->GetRight() <> Nil) {
			return Get(current->GetRight(), key);	
		}
		else {
			return current->GetValue();
		};

		return Nil;
	}

	method : public : Size() ~ Int {
		return @size;
	}
}